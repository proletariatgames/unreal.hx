/**
 *
 * WARNING! This file was autogenerated by:
 *  _   _ _   _ __   __
 * | | | | | | |\ \ / /
 * | | | | |_| | \ V /
 * | | | |  _  | /   \
 * | |_| | | | |/ /^\ \
 *  \___/\_| |_/\/   \/
 *
 * This file was autogenerated by UnrealHxGenerator using UHT definitions.
 * It only includes UPROPERTYs and UFUNCTIONs. Do not modify it!
 * In order to add more definitions, create or edit a type with the same name/package, but with an `_Extra` suffix
**/
package unreal;

@:glueCppIncludes("Kismet/KismetSystemLibrary.h")
@:uextern @:uclass extern class UKismetSystemLibrary extends unreal.UBlueprintFunctionLibrary {

  /**
    Prints a stack trace to the log, so you can see how a blueprint got to this node
  **/
  // @:ufunction(BlueprintCallable) static public function StackTrace() : Void;

  /**
    Return true if the object is usable : non-null and not pending kill
  **/
  @:ufunction(BlueprintCallable) static public function IsValid(Object : unreal.Const<unreal.UObject>) : Bool;

  /**
    Return true if the class is usable : non-null and not pending kill
  **/
  @:ufunction(BlueprintCallable) static public function IsValidClass(Class : unreal.UClass) : Bool;

  /**
    Returns the actual object name.
  **/
  @:ufunction(BlueprintCallable) static public function GetObjectName(Object : unreal.Const<unreal.UObject>) : unreal.FString;

  /**
    Returns the full path to the specified object.
  **/
  @:ufunction(BlueprintCallable) static public function GetPathName(Object : unreal.Const<unreal.UObject>) : unreal.FString;

  /**
    Returns the display name (or actor label), for displaying as a debugging aid.
    Note: In editor builds, this is the actor label.  In non-editor builds, this is the actual object name.  This function should not be used to uniquely identify actors!
    It is not localized and should not be used for display to an end user of a game.
  **/
  @:ufunction(BlueprintCallable) static public function GetDisplayName(Object : unreal.Const<unreal.UObject>) : unreal.FString;

  /**
    Returns the display name of a class
  **/
  @:ufunction(BlueprintCallable) static public function GetClassDisplayName(Class : unreal.UClass) : unreal.FString;

  /**
    Returns the outer object of an object.
  **/
  @:ufunction(BlueprintCallable) static public function GetOuterObject(Object : unreal.Const<unreal.UObject>) : unreal.UObject;

  /**
    Engine build number, for displaying to end users.
  **/
  @:ufunction(BlueprintCallable) static public function GetEngineVersion() : unreal.FString;

  /**
    Get the name of the current game
  **/
  @:ufunction(BlueprintCallable) static public function GetGameName() : unreal.FString;

  /**
    Get the directory of the current project
  **/
  @:ufunction(BlueprintCallable) static public function GetProjectDirectory() : unreal.FString;

  /**
    Get the content directory of the current project
  **/
  @:ufunction(BlueprintCallable) static public function GetProjectContentDirectory() : unreal.FString;

  /**
    Get the saved directory of the current project
  **/
  @:ufunction(BlueprintCallable) static public function GetProjectSavedDirectory() : unreal.FString;

  /**
    Converts passed in filename to use a relative path
  **/
  @:ufunction(BlueprintCallable) static public function ConvertToRelativePath(FileName : unreal.FString) : unreal.FString;

  /**
    Converts passed in filename to use a absolute path
  **/
  @:ufunction(BlueprintCallable) static public function ConvertToAbsolutePath(FileName : unreal.FString) : unreal.FString;

  /**
    Convert all / and \ to TEXT("/")
  **/
  @:ufunction(BlueprintCallable) static public function NormalizeFilename(InFilename : unreal.FString) : unreal.FString;

  /**
    Retrieves the game's platform-specific bundle identifier or package name of the game

    @return The game's bundle identifier or package name.
  **/
  @:ufunction(BlueprintCallable) static public function GetGameBundleId() : unreal.FString;

  /**
    Get the current user name from the OS
  **/
  @:ufunction(BlueprintCallable) static public function GetPlatformUserName() : unreal.FString;
  @:ufunction(BlueprintCallable) static public function DoesImplementInterface(TestObject : unreal.UObject, Interface : unreal.TSubclassOf<unreal.IInterface>) : Bool;

  /**
    Get the current game time, in seconds. This stops when the game is paused and is affected by slomo.

    @param WorldContextObject    World context
  **/
  @:ufunction(BlueprintCallable) static public function GetGameTimeInSeconds(WorldContextObject : unreal.UObject) : unreal.Float32;

  /**
    Returns whether the world this object is in is the host or not
  **/
  @:ufunction(BlueprintCallable) static public function IsServer(WorldContextObject : unreal.UObject) : Bool;

  /**
    Returns whether this is running on a dedicated server
  **/
  @:ufunction(BlueprintCallable) static public function IsDedicatedServer(WorldContextObject : unreal.UObject) : Bool;

  /**
    Returns whether this game instance is stand alone (no networking).
  **/
  @:ufunction(BlueprintCallable) static public function IsStandalone(WorldContextObject : unreal.UObject) : Bool;

  /**
    Returns whether this is a build that is packaged for distribution
  **/
  @:ufunction(BlueprintCallable) static public function IsPackagedForDistribution() : Bool;

  /**
    Returns the platform specific unique device id
  **/
  @:ufunction(BlueprintCallable) static public function GetUniqueDeviceId() : unreal.FString;

  /**
    Returns the platform specific unique device id
  **/
  @:ufunction(BlueprintCallable) static public function GetDeviceId() : unreal.FString;

  /**
    Builds a SoftObjectPath struct. Generally you should be using Soft Object References/Ptr types instead
  **/
  @:ufunction(BlueprintCallable) static public function MakeSoftObjectPath(PathString : unreal.FString) : unreal.FSoftObjectPath;

  /**
    Gets the path string out of a Soft Object Path
  **/
  @:ufunction(BlueprintCallable) static public function BreakSoftObjectPath(InSoftObjectPath : unreal.FSoftObjectPath, PathString : unreal.PRef<unreal.FString>) : Void;

  /**
    Builds a SoftClassPath struct. Generally you should be using Soft Class References/Ptr types instead
  **/
  @:ufunction(BlueprintCallable) static public function MakeSoftClassPath(PathString : unreal.FString) : unreal.FSoftClassPath;

  /**
    Gets the path string out of a Soft Class Path
  **/
  @:ufunction(BlueprintCallable) static public function BreakSoftClassPath(InSoftClassPath : unreal.FSoftClassPath, PathString : unreal.PRef<unreal.FString>) : Void;

  /**
    Creates a literal integer
    @param       Value   value to set the integer to
    @return      The literal integer
  **/
  @:ufunction(BlueprintCallable) static public function MakeLiteralInt(Value : unreal.Int32) : unreal.Int32;

  /**
    Creates a literal float
    @param       Value   value to set the float to
    @return      The literal float
  **/
  @:ufunction(BlueprintCallable) static public function MakeLiteralFloat(Value : unreal.Float32) : unreal.Float32;

  /**
    Creates a literal bool
    @param       Value   value to set the bool to
    @return      The literal bool
  **/
  @:ufunction(BlueprintCallable) static public function MakeLiteralBool(Value : Bool) : Bool;

  /**
    Creates a literal name
    @param       Value   value to set the name to
    @return      The literal name
  **/
  @:ufunction(BlueprintCallable) static public function MakeLiteralName(Value : unreal.FName) : unreal.FName;

  /**
    Creates a literal byte
    @param       Value   value to set the byte to
    @return      The literal byte
  **/
  @:ufunction(BlueprintCallable) static public function MakeLiteralByte(Value : unreal.UInt8) : unreal.UInt8;

  /**
    Creates a literal string
    @param       Value   value to set the string to
    @return      The literal string
  **/
  @:ufunction(BlueprintCallable) static public function MakeLiteralString(Value : unreal.FString) : unreal.FString;

  /**
    Creates a literal FText
    @param       Value   value to set the FText to
    @return      The literal FText
  **/
  @:ufunction(BlueprintCallable) static public function MakeLiteralText(Value : unreal.FText) : unreal.FText;

  /**
    Prints a string to the log, and optionally, to the screen
    If Print To Log is true, it will be visible in the Output Log window.  Otherwise it will be logged only as 'Verbose', so it generally won't show up.

    @param       InString                The string to log out
    @param       bPrintToScreen  Whether or not to print the output to the screen
    @param       bPrintToLog             Whether or not to print the output to the log
    @param       bPrintToConsole Whether or not to print the output to the console
    @param       TextColor               Whether or not to print the output to the console
    @param       Duration                The display duration (if Print to Screen is True). Using negative number will result in loading the duration time from the config.
  **/
  @:ufunction(BlueprintCallable) static public function PrintString(WorldContextObject : unreal.UObject, InString : unreal.FString = "Hello", bPrintToScreen : Bool = true, bPrintToLog : Bool = true, @:opt("(R=0.000000,G=0.660000,B=1.000000,A=1.000000)") TextColor : unreal.FLinearColor, Duration : unreal.Float32 = 2.000000) : Void;

  /**
    Prints text to the log, and optionally, to the screen
    If Print To Log is true, it will be visible in the Output Log window.  Otherwise it will be logged only as 'Verbose', so it generally won't show up.

    @param       InText                  The text to log out
    @param       bPrintToScreen  Whether or not to print the output to the screen
    @param       bPrintToLog             Whether or not to print the output to the log
    @param       bPrintToConsole Whether or not to print the output to the console
    @param       TextColor               Whether or not to print the output to the console
    @param       Duration                The display duration (if Print to Screen is True). Using negative number will result in loading the duration time from the config.
  **/
  @:ufunction(BlueprintCallable) static public function PrintText(WorldContextObject : unreal.UObject, InText : unreal.Const<unreal.FText> = "INVTEXT(\"Hello\")", bPrintToScreen : Bool = true, bPrintToLog : Bool = true, @:opt("(R=0.000000,G=0.660000,B=1.000000,A=1.000000)") TextColor : unreal.FLinearColor, Duration : unreal.Float32 = 2.000000) : Void;

  /**
    Prints a warning string to the log and the screen. Meant to be used as a way to inform the user that they misused the node.

    WARNING!! Don't change the signature of this function without fixing up all nodes using it in the compiler

    @param       InString                The string to log out
  **/
  @:ufunction(BlueprintCallable) static public function PrintWarning(InString : unreal.FString) : Void;

  /**
    Sets the game window title
  **/
  @:ufunction(BlueprintCallable) static public function SetWindowTitle(Title : unreal.Const<unreal.PRef<unreal.FText>>) : Void;

  /**
    Executes a console command, optionally on a specific controller

    @param       Command                 Command to send to the console
    @param       SpecificPlayer  If specified, the console command will be routed through the specified player
  **/
  @:ufunction(BlueprintCallable) static public function ExecuteConsoleCommand(WorldContextObject : unreal.UObject, Command : unreal.FString, @:opt("None") SpecificPlayer : unreal.APlayerController) : Void;

  /**
    Attempts to retrieve the value of the specified float console variable, if it exists.

    @param       VariableName    Name of the console variable to find.
    @return      The value if found, 0 otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function GetConsoleVariableFloatValue(VariableName : unreal.FString) : unreal.Float32;

  /**
    Attempts to retrieve the value of the specified integer console variable, if it exists.

    @param       VariableName    Name of the console variable to find.
    @return      The value if found, 0 otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function GetConsoleVariableIntValue(VariableName : unreal.FString) : unreal.Int32;

  /**
    Evaluates, if it exists, whether the specified integer console variable has a non-zero value (true) or not (false).

    @param       VariableName    Name of the console variable to find.
    @return      True if found and has a non-zero value, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function GetConsoleVariableBoolValue(VariableName : unreal.FString) : Bool;

  /**
    Exit the current game
    @param       SpecificPlayer  The specific player to quit the game. If not specified, player 0 will quit.
    @param       QuitPreference  Form of quitting.
    @param       bIgnorePlatformRestrictions     Ignores and best-practices based on platform (e.g PS4 games should never quit). Non-shipping only
  **/
  @:ufunction(BlueprintCallable) static public function QuitGame(WorldContextObject : unreal.UObject, SpecificPlayer : unreal.APlayerController, QuitPreference : unreal.EQuitPreference, bIgnorePlatformRestrictions : Bool) : Void;

  /**
    Perform a latent action with a delay (specified in seconds).  Calling again while it is counting down will be ignored.

    @param WorldContext  World context.
    @param Duration              length of delay (in seconds).
    @param LatentInfo    The latent action.
  **/
  @:ufunction(BlueprintCallable) static public function Delay(WorldContextObject : unreal.UObject, @:bpopt("0.2") Duration : unreal.Float32, @:bpopt("LatentInfo") LatentInfo : unreal.FLatentActionInfo) : Void;

  /**
    Perform a latent action with a retriggerable delay (specified in seconds).  Calling again while it is counting down will reset the countdown to Duration.

    @param WorldContext  World context.
    @param Duration              length of delay (in seconds).
    @param LatentInfo    The latent action.
  **/
  @:ufunction(BlueprintCallable) static public function RetriggerableDelay(WorldContextObject : unreal.UObject, @:bpopt("0.2") Duration : unreal.Float32, @:bpopt("LatentInfo") LatentInfo : unreal.FLatentActionInfo) : Void;

  /**
    * Interpolate a component to the specified relative location and rotation over the course of OverTime seconds.
    * @param Component                                             Component to interpolate
    * @param TargetRelativeLocation                Relative target location
    * @param TargetRelativeRotation                Relative target rotation
    * @param bEaseOut                                              if true we will ease out (ie end slowly) during interpolation
    * @param bEaseIn                                               if true we will ease in (ie start slowly) during interpolation
    * @param OverTime                                              duration of interpolation
    * @param bForceShortestRotationPath    if true we will always use the shortest path for rotation
    * @param MoveAction                                    required movement behavior @see EMoveComponentAction
    * @param LatentInfo                                    The latent action
  **/
  @:ufunction(BlueprintCallable) static public function MoveComponentTo(Component : unreal.USceneComponent, TargetRelativeLocation : unreal.FVector, TargetRelativeRotation : unreal.FRotator, bEaseOut : Bool, bEaseIn : Bool, @:bpopt("0.2") OverTime : unreal.Float32, bForceShortestRotationPath : Bool, MoveAction : unreal.EMoveComponentAction, @:bpopt("LatentInfo") LatentInfo : unreal.FLatentActionInfo) : Void;

  /**
    Set a timer to execute delegate. Setting an existing timer will reset that timer with updated parameters.
    @param Event                 Event. Can be a K2 function or a Custom Event.
    @param Time                  How long to wait before executing the delegate, in seconds. Setting a timer to <= 0 seconds will clear it if it is set.
    @param bLooping              True to keep executing the delegate every Time seconds, false to execute delegate only once.
    @return                              The timer handle to pass to other timer functions to manipulate this timer.
  **/
  @:ufunction(BlueprintCallable) static public function K2_SetTimerDelegate(Delegate : unreal.FTimerDynamicDelegate, Time : unreal.Float32, bLooping : Bool) : unreal.FTimerHandle;

  /**
    Clears a set timer.
    @param Event  Can be a K2 function or a Custom Event.
  **/
  @:ufunction(BlueprintCallable) static public function K2_ClearTimerDelegate(Delegate : unreal.FTimerDynamicDelegate) : Void;

  /**
    Pauses a set timer at its current elapsed time.
    @param Event  Can be a K2 function or a Custom Event.
  **/
  @:ufunction(BlueprintCallable) static public function K2_PauseTimerDelegate(Delegate : unreal.FTimerDynamicDelegate) : Void;

  /**
    Resumes a paused timer from its current elapsed time.
    @param Event  Can be a K2 function or a Custom Event.
  **/
  @:ufunction(BlueprintCallable) static public function K2_UnPauseTimerDelegate(Delegate : unreal.FTimerDynamicDelegate) : Void;

  /**
    Returns true if a timer exists and is active for the given delegate, false otherwise.
    @param Event  Can be a K2 function or a Custom Event.
    @return                              True if the timer exists and is active.
  **/
  @:ufunction(BlueprintCallable) static public function K2_IsTimerActiveDelegate(Delegate : unreal.FTimerDynamicDelegate) : Bool;

  /**
    Returns true if a timer exists and is paused for the given delegate, false otherwise.
    @param Event  Can be a K2 function or a Custom Event.
    @return                              True if the timer exists and is paused.
  **/
  @:ufunction(BlueprintCallable) static public function K2_IsTimerPausedDelegate(Delegate : unreal.FTimerDynamicDelegate) : Bool;

  /**
    Returns true is a timer for the given delegate exists, false otherwise.
    @param Event  Can be a K2 function or a Custom Event.
    @return                              True if the timer exists.
  **/
  @:ufunction(BlueprintCallable) static public function K2_TimerExistsDelegate(Delegate : unreal.FTimerDynamicDelegate) : Bool;

  /**
    Returns elapsed time for the given delegate (time since current countdown iteration began).
    @param Event  Can be a K2 function or a Custom Event.
    @return                              How long has elapsed since the current iteration of the timer began.
  **/
  @:ufunction(BlueprintCallable) static public function K2_GetTimerElapsedTimeDelegate(Delegate : unreal.FTimerDynamicDelegate) : unreal.Float32;

  /**
    Returns time until the timer will next execute its delegate.
    @param Event  Can be a K2 function or a Custom Event.
    @return                              How long is remaining in the current iteration of the timer.
  **/
  @:ufunction(BlueprintCallable) static public function K2_GetTimerRemainingTimeDelegate(Delegate : unreal.FTimerDynamicDelegate) : unreal.Float32;

  /**
    Returns whether the timer handle is valid. This does not indicate that there is an active timer that this handle references, but rather that it once referenced a valid timer.
    @param Handle                The handle of the timer to check validity of.
    @return                              Whether the timer handle is valid.
  **/
  @:ufunction(BlueprintCallable) static public function K2_IsValidTimerHandle(Handle : unreal.FTimerHandle) : Bool;

  /**
    Invalidate the supplied TimerHandle and return it.
    @param Handle                The handle of the timer to invalidate.
    @return                              Return the invalidated timer handle for convenience.
  **/
  @:ufunction(BlueprintCallable) static public function K2_InvalidateTimerHandle(Handle : unreal.PRef<unreal.FTimerHandle>) : unreal.FTimerHandle;

  /**
    Clears a set timer.
    @param Handle                The handle of the timer to clear.
  **/
  @:ufunction(BlueprintCallable) static public function K2_ClearTimerHandle(WorldContextObject : unreal.UObject, Handle : unreal.FTimerHandle) : Void;

  /**
    Clears a set timer.
    @param Handle                The handle of the timer to clear.
  **/
  @:ufunction(BlueprintCallable) static public function K2_ClearAndInvalidateTimerHandle(WorldContextObject : unreal.UObject, Handle : unreal.PRef<unreal.FTimerHandle>) : Void;

  /**
    Pauses a set timer at its current elapsed time.
    @param Handle                The handle of the timer to pause.
  **/
  @:ufunction(BlueprintCallable) static public function K2_PauseTimerHandle(WorldContextObject : unreal.UObject, Handle : unreal.FTimerHandle) : Void;

  /**
    Resumes a paused timer from its current elapsed time.
    @param Handle                The handle of the timer to unpause.
  **/
  @:ufunction(BlueprintCallable) static public function K2_UnPauseTimerHandle(WorldContextObject : unreal.UObject, Handle : unreal.FTimerHandle) : Void;

  /**
    Returns true if a timer exists and is active for the given handle, false otherwise.
    @param Handle                The handle of the timer to check whether it is active.
    @return                              True if the timer exists and is active.
  **/
  @:ufunction(BlueprintCallable) static public function K2_IsTimerActiveHandle(WorldContextObject : unreal.UObject, Handle : unreal.FTimerHandle) : Bool;

  /**
    Returns true if a timer exists and is paused for the given handle, false otherwise.
    @param Handle                The handle of the timer to check whether it is paused.
    @return                              True if the timer exists and is paused.
  **/
  @:ufunction(BlueprintCallable) static public function K2_IsTimerPausedHandle(WorldContextObject : unreal.UObject, Handle : unreal.FTimerHandle) : Bool;

  /**
    Returns true is a timer for the given handle exists, false otherwise.
    @param Handle                The handle to check whether it exists.
    @return                              True if the timer exists.
  **/
  @:ufunction(BlueprintCallable) static public function K2_TimerExistsHandle(WorldContextObject : unreal.UObject, Handle : unreal.FTimerHandle) : Bool;

  /**
    Returns elapsed time for the given handle (time since current countdown iteration began).
    @param Handle                The handle of the timer to get the elapsed time of.
    @return                              How long has elapsed since the current iteration of the timer began.
  **/
  @:ufunction(BlueprintCallable) static public function K2_GetTimerElapsedTimeHandle(WorldContextObject : unreal.UObject, Handle : unreal.FTimerHandle) : unreal.Float32;

  /**
    Returns time until the timer will next execute its handle.
    @param Handle                The handle of the timer to time remaining of.
    @return                              How long is remaining in the current iteration of the timer.
  **/
  @:ufunction(BlueprintCallable) static public function K2_GetTimerRemainingTimeHandle(WorldContextObject : unreal.UObject, Handle : unreal.FTimerHandle) : unreal.Float32;

  /**
    Set a timer to execute delegate. Setting an existing timer will reset that timer with updated parameters.
    @param Object                Object that implements the delegate function. Defaults to self (this blueprint)
    @param FunctionName  Delegate function name. Can be a K2 function or a Custom Event.
    @param Time                  How long to wait before executing the delegate, in seconds. Setting a timer to <= 0 seconds will clear it if it is set.
    @param bLooping              true to keep executing the delegate every Time seconds, false to execute delegate only once.
    @return                              The timer handle to pass to other timer functions to manipulate this timer.
  **/
  @:ufunction(BlueprintCallable) static public function K2_SetTimer(Object : unreal.UObject, FunctionName : unreal.FString, Time : unreal.Float32, bLooping : Bool) : unreal.FTimerHandle;

  /**
    Clears a set timer.
    @param Object                Object that implements the delegate function. Defaults to self (this blueprint)
    @param FunctionName  Delegate function name. Can be a K2 function or a Custom Event.
  **/
  @:ufunction(BlueprintCallable) static public function K2_ClearTimer(Object : unreal.UObject, FunctionName : unreal.FString) : Void;

  /**
    Pauses a set timer at its current elapsed time.
    @param Object                Object that implements the delegate function. Defaults to self (this blueprint)
    @param FunctionName  Delegate function name. Can be a K2 function or a Custom Event.
  **/
  @:ufunction(BlueprintCallable) static public function K2_PauseTimer(Object : unreal.UObject, FunctionName : unreal.FString) : Void;

  /**
    Resumes a paused timer from its current elapsed time.
    @param Object                Object that implements the delegate function. Defaults to self (this blueprint)
    @param FunctionName  Delegate function name. Can be a K2 function or a Custom Event.
  **/
  @:ufunction(BlueprintCallable) static public function K2_UnPauseTimer(Object : unreal.UObject, FunctionName : unreal.FString) : Void;

  /**
    Returns true if a timer exists and is active for the given delegate, false otherwise.
    @param Object                Object that implements the delegate function. Defaults to self (this blueprint)
    @param FunctionName  Delegate function name. Can be a K2 function or a Custom Event.
    @return                              True if the timer exists and is active.
  **/
  @:ufunction(BlueprintCallable) static public function K2_IsTimerActive(Object : unreal.UObject, FunctionName : unreal.FString) : Bool;

  /**
    Returns true if a timer exists and is paused for the given delegate, false otherwise.
    @param Object         Object that implements the delegate function. Defaults to self (this blueprint)
    @param FunctionName   Delegate function name. Can be a K2 function or a Custom Event.
    @return                               True if the timer exists and is paused.
  **/
  @:ufunction(BlueprintCallable) static public function K2_IsTimerPaused(Object : unreal.UObject, FunctionName : unreal.FString) : Bool;

  /**
    Returns true is a timer for the given delegate exists, false otherwise.
    @param Object         Object that implements the delegate function. Defaults to self (this blueprint)
    @param FunctionName   Delegate function name. Can be a K2 function or a Custom Event.
    @return                               True if the timer exists.
  **/
  @:ufunction(BlueprintCallable) static public function K2_TimerExists(Object : unreal.UObject, FunctionName : unreal.FString) : Bool;

  /**
    Returns elapsed time for the given delegate (time since current countdown iteration began).
    @param Object                Object that implements the delegate function. Defaults to self (this blueprint)
    @param FunctionName  Delegate function name. Can be a K2 function or a Custom Event.
    @return                              How long has elapsed since the current iteration of the timer began.
  **/
  @:ufunction(BlueprintCallable) static public function K2_GetTimerElapsedTime(Object : unreal.UObject, FunctionName : unreal.FString) : unreal.Float32;

  /**
    Returns time until the timer will next execute its delegate.
    @param Object                Object that implements the delegate function. Defaults to self (this blueprint)
    @param FunctionName  Delegate function name. Can be a K2 function or a Custom Event.
    @return                              How long is remaining in the current iteration of the timer.
  **/
  @:ufunction(BlueprintCallable) static public function K2_GetTimerRemainingTime(Object : unreal.UObject, FunctionName : unreal.FString) : unreal.Float32;

  /**
    Set an int32 property by name
  **/
  @:ufunction(BlueprintCallable) static public function SetIntPropertyByName(Object : unreal.UObject, PropertyName : unreal.FName, Value : unreal.Int32) : Void;

  /**
    Set an int64 property by name
  **/
  @:ufunction(BlueprintCallable) static public function SetInt64PropertyByName(Object : unreal.UObject, PropertyName : unreal.FName, Value : unreal.Int64) : Void;

  /**
    Set an uint8 or enum property by name
  **/
  @:ufunction(BlueprintCallable) static public function SetBytePropertyByName(Object : unreal.UObject, PropertyName : unreal.FName, Value : unreal.UInt8) : Void;

  /**
    Set a float property by name
  **/
  @:ufunction(BlueprintCallable) static public function SetFloatPropertyByName(Object : unreal.UObject, PropertyName : unreal.FName, Value : unreal.Float32) : Void;

  /**
    Set a bool property by name
  **/
  @:ufunction(BlueprintCallable) static public function SetBoolPropertyByName(Object : unreal.UObject, PropertyName : unreal.FName, Value : Bool) : Void;

  /**
    Set an OBJECT property by name
  **/
  @:ufunction(BlueprintCallable) static public function SetObjectPropertyByName(Object : unreal.UObject, PropertyName : unreal.FName, Value : unreal.UObject) : Void;

  /**
    Set a CLASS property by name
  **/
  @:ufunction(BlueprintCallable) static public function SetClassPropertyByName(Object : unreal.UObject, PropertyName : unreal.FName, Value : unreal.TSubclassOf<unreal.UObject>) : Void;

  /**
    Set a NAME property by name
  **/
  @:ufunction(BlueprintCallable) static public function SetNamePropertyByName(Object : unreal.UObject, PropertyName : unreal.FName, Value : unreal.Const<unreal.PRef<unreal.FName>>) : Void;

  /**
    Set a STRING property by name
  **/
  @:ufunction(BlueprintCallable) static public function SetStringPropertyByName(Object : unreal.UObject, PropertyName : unreal.FName, Value : unreal.FString) : Void;

  /**
    Set a TEXT property by name
  **/
  @:ufunction(BlueprintCallable) static public function SetTextPropertyByName(Object : unreal.UObject, PropertyName : unreal.FName, Value : unreal.Const<unreal.PRef<unreal.FText>>) : Void;

  /**
    Set a VECTOR property by name
  **/
  @:ufunction(BlueprintCallable) static public function SetVectorPropertyByName(Object : unreal.UObject, PropertyName : unreal.FName, Value : unreal.Const<unreal.PRef<unreal.FVector>>) : Void;

  /**
    Set a ROTATOR property by name
  **/
  @:ufunction(BlueprintCallable) static public function SetRotatorPropertyByName(Object : unreal.UObject, PropertyName : unreal.FName, Value : unreal.Const<unreal.PRef<unreal.FRotator>>) : Void;

  /**
    Set a LINEAR COLOR property by name
  **/
  @:ufunction(BlueprintCallable) static public function SetLinearColorPropertyByName(Object : unreal.UObject, PropertyName : unreal.FName, Value : unreal.Const<unreal.PRef<unreal.FLinearColor>>) : Void;

  /**
    Set a TRANSFORM property by name
  **/
  @:ufunction(BlueprintCallable) static public function SetTransformPropertyByName(Object : unreal.UObject, PropertyName : unreal.FName, Value : unreal.Const<unreal.PRef<unreal.FTransform>>) : Void;

  /**
    Set a CollisionProfileName property by name
  **/
  @:ufunction(BlueprintCallable) static public function SetCollisionProfileNameProperty(Object : unreal.UObject, PropertyName : unreal.FName, Value : unreal.Const<unreal.PRef<unreal.FCollisionProfileName>>) : Void;

  /**
    Set a custom structure property by name
  **/
  @:ufunction(BlueprintCallable) static public function SetStructurePropertyByName(Object : unreal.UObject, PropertyName : unreal.FName, Value : unreal.Const<unreal.PRef<unreal.FGenericStruct>>) : Void;

  /**
    Does a collision trace along the given line and returns the first blocking hit encountered.
    This trace finds the objects that RESPONDS to the given TraceChannel

    @param WorldContext  World context
    @param Start                 Start of line segment.
    @param End                   End of line segment.
    @param TraceChannel
    @param bTraceComplex True to test against complex collision, false to test against simplified collision.
    @param OutHit                Properties of the trace hit.
    @return                              True if there was a hit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function LineTraceSingle(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, TraceChannel : unreal.ETraceTypeQuery, bTraceComplex : Bool, ActorsToIgnore : unreal.Const<unreal.PRef<unreal.TArray<unreal.AActor>>>, DrawDebugType : unreal.EDrawDebugTrace, OutHit : unreal.PRef<unreal.FHitResult>, @:bpopt("true") bIgnoreSelf : Bool, @:opt("(R=1.000000,G=0.000000,B=0.000000,A=1.000000)") TraceColor : unreal.FLinearColor, @:opt("(R=0.000000,G=1.000000,B=0.000000,A=1.000000)") TraceHitColor : unreal.FLinearColor, DrawTime : unreal.Float32 = 5.000000) : Bool;

  /**
    Does a collision trace along the given line and returns all hits encountered up to and including the first blocking hit.
    This trace finds the objects that RESPOND to the given TraceChannel

    @param WorldContext  World context
    @param Start                 Start of line segment.
    @param End                   End of line segment.
    @param TraceChannel  The channel to trace
    @param bTraceComplex True to test against complex collision, false to test against simplified collision.
    @param OutHit                Properties of the trace hit.
    @return                              True if there was a blocking hit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function LineTraceMulti(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, TraceChannel : unreal.ETraceTypeQuery, bTraceComplex : Bool, ActorsToIgnore : unreal.Const<unreal.PRef<unreal.TArray<unreal.AActor>>>, DrawDebugType : unreal.EDrawDebugTrace, OutHits : unreal.PRef<unreal.TArray<unreal.FHitResult>>, @:bpopt("true") bIgnoreSelf : Bool, @:opt("(R=1.000000,G=0.000000,B=0.000000,A=1.000000)") TraceColor : unreal.FLinearColor, @:opt("(R=0.000000,G=1.000000,B=0.000000,A=1.000000)") TraceHitColor : unreal.FLinearColor, DrawTime : unreal.Float32 = 5.000000) : Bool;

  /**
    Sweeps a sphere along the given line and returns the first blocking hit encountered.
    This trace finds the objects that RESPONDS to the given TraceChannel

    @param Start                 Start of line segment.
    @param End                   End of line segment.
    @param Radius                Radius of the sphere to sweep
    @param TraceChannel
    @param bTraceComplex True to test against complex collision, false to test against simplified collision.
    @param OutHit                Properties of the trace hit.
    @return                              True if there was a hit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function SphereTraceSingle(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, Radius : unreal.Float32, TraceChannel : unreal.ETraceTypeQuery, bTraceComplex : Bool, ActorsToIgnore : unreal.Const<unreal.PRef<unreal.TArray<unreal.AActor>>>, DrawDebugType : unreal.EDrawDebugTrace, OutHit : unreal.PRef<unreal.FHitResult>, @:bpopt("true") bIgnoreSelf : Bool, @:opt("(R=1.000000,G=0.000000,B=0.000000,A=1.000000)") TraceColor : unreal.FLinearColor, @:opt("(R=0.000000,G=1.000000,B=0.000000,A=1.000000)") TraceHitColor : unreal.FLinearColor, DrawTime : unreal.Float32 = 5.000000) : Bool;

  /**
    Sweeps a sphere along the given line and returns all hits encountered up to and including the first blocking hit.
    This trace finds the objects that RESPOND to the given TraceChannel

    @param WorldContext  World context
    @param Start                 Start of line segment.
    @param End                   End of line segment.
    @param Radius                Radius of the sphere to sweep
    @param TraceChannel
    @param bTraceComplex True to test against complex collision, false to test against simplified collision.
    @param OutHits               A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.
    @return                              True if there was a blocking hit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function SphereTraceMulti(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, Radius : unreal.Float32, TraceChannel : unreal.ETraceTypeQuery, bTraceComplex : Bool, ActorsToIgnore : unreal.Const<unreal.PRef<unreal.TArray<unreal.AActor>>>, DrawDebugType : unreal.EDrawDebugTrace, OutHits : unreal.PRef<unreal.TArray<unreal.FHitResult>>, @:bpopt("true") bIgnoreSelf : Bool, @:opt("(R=1.000000,G=0.000000,B=0.000000,A=1.000000)") TraceColor : unreal.FLinearColor, @:opt("(R=0.000000,G=1.000000,B=0.000000,A=1.000000)") TraceHitColor : unreal.FLinearColor, DrawTime : unreal.Float32 = 5.000000) : Bool;

  /**
    Sweeps a box along the given line and returns the first blocking hit encountered.
    This trace finds the objects that RESPONDS to the given TraceChannel

    @param Start                  Start of line segment.
    @param End                    End of line segment.
    @param HalfSize           Distance from the center of box along each axis
    @param Orientation    Orientation of the box
    @param TraceChannel
    @param bTraceComplex  True to test against complex collision, false to test against simplified collision.
    @param OutHit                 Properties of the trace hit.
    @return                               True if there was a hit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function BoxTraceSingle(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, HalfSize : unreal.Const<unreal.FVector>, Orientation : unreal.Const<unreal.FRotator>, TraceChannel : unreal.ETraceTypeQuery, bTraceComplex : Bool, ActorsToIgnore : unreal.Const<unreal.PRef<unreal.TArray<unreal.AActor>>>, DrawDebugType : unreal.EDrawDebugTrace, OutHit : unreal.PRef<unreal.FHitResult>, @:bpopt("true") bIgnoreSelf : Bool, @:opt("(R=1.000000,G=0.000000,B=0.000000,A=1.000000)") TraceColor : unreal.FLinearColor, @:opt("(R=0.000000,G=1.000000,B=0.000000,A=1.000000)") TraceHitColor : unreal.FLinearColor, DrawTime : unreal.Float32 = 5.000000) : Bool;

  /**
    Sweeps a box along the given line and returns all hits encountered.
    This trace finds the objects that RESPONDS to the given TraceChannel

    @param Start                  Start of line segment.
    @param End                    End of line segment.
    @param HalfSize           Distance from the center of box along each axis
    @param Orientation    Orientation of the box
    @param TraceChannel
    @param bTraceComplex  True to test against complex collision, false to test against simplified collision.
    @param OutHits                A list of hits, sorted along the trace from start to finish. The blocking hit will be the last hit, if there was one.
    @return                               True if there was a blocking hit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function BoxTraceMulti(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, HalfSize : unreal.FVector, Orientation : unreal.Const<unreal.FRotator>, TraceChannel : unreal.ETraceTypeQuery, bTraceComplex : Bool, ActorsToIgnore : unreal.Const<unreal.PRef<unreal.TArray<unreal.AActor>>>, DrawDebugType : unreal.EDrawDebugTrace, OutHits : unreal.PRef<unreal.TArray<unreal.FHitResult>>, @:bpopt("true") bIgnoreSelf : Bool, @:opt("(R=1.000000,G=0.000000,B=0.000000,A=1.000000)") TraceColor : unreal.FLinearColor, @:opt("(R=0.000000,G=1.000000,B=0.000000,A=1.000000)") TraceHitColor : unreal.FLinearColor, DrawTime : unreal.Float32 = 5.000000) : Bool;

  /**
    Sweeps a capsule along the given line and returns the first blocking hit encountered.
    This trace finds the objects that RESPOND to the given TraceChannel

    @param WorldContext  World context
    @param Start                 Start of line segment.
    @param End                   End of line segment.
    @param Radius                Radius of the capsule to sweep
    @param HalfHeight    Distance from center of capsule to tip of hemisphere endcap.
    @param TraceChannel
    @param bTraceComplex True to test against complex collision, false to test against simplified collision.
    @param OutHit                Properties of the trace hit.
    @return                              True if there was a hit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function CapsuleTraceSingle(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, Radius : unreal.Float32, HalfHeight : unreal.Float32, TraceChannel : unreal.ETraceTypeQuery, bTraceComplex : Bool, ActorsToIgnore : unreal.Const<unreal.PRef<unreal.TArray<unreal.AActor>>>, DrawDebugType : unreal.EDrawDebugTrace, OutHit : unreal.PRef<unreal.FHitResult>, @:bpopt("true") bIgnoreSelf : Bool, @:opt("(R=1.000000,G=0.000000,B=0.000000,A=1.000000)") TraceColor : unreal.FLinearColor, @:opt("(R=0.000000,G=1.000000,B=0.000000,A=1.000000)") TraceHitColor : unreal.FLinearColor, DrawTime : unreal.Float32 = 5.000000) : Bool;

  /**
    Sweeps a capsule along the given line and returns all hits encountered up to and including the first blocking hit.
    This trace finds the objects that RESPOND to the given TraceChannel

    @param WorldContext  World context
    @param Start                 Start of line segment.
    @param End                   End of line segment.
    @param Radius                Radius of the capsule to sweep
    @param HalfHeight    Distance from center of capsule to tip of hemisphere endcap.
    @param TraceChannel
    @param bTraceComplex True to test against complex collision, false to test against simplified collision.
    @param OutHits               A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.
    @return                              True if there was a blocking hit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function CapsuleTraceMulti(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, Radius : unreal.Float32, HalfHeight : unreal.Float32, TraceChannel : unreal.ETraceTypeQuery, bTraceComplex : Bool, ActorsToIgnore : unreal.Const<unreal.PRef<unreal.TArray<unreal.AActor>>>, DrawDebugType : unreal.EDrawDebugTrace, OutHits : unreal.PRef<unreal.TArray<unreal.FHitResult>>, @:bpopt("true") bIgnoreSelf : Bool, @:opt("(R=1.000000,G=0.000000,B=0.000000,A=1.000000)") TraceColor : unreal.FLinearColor, @:opt("(R=0.000000,G=1.000000,B=0.000000,A=1.000000)") TraceHitColor : unreal.FLinearColor, DrawTime : unreal.Float32 = 5.000000) : Bool;

  /**
    Trace a ray against the world using a specific profile and return the first blocking hit

    @param WorldContext   World context
    @param Start                  Start of line segment.
    @param End                    End of line segment.
    @param ProfileName    The 'profile' used to determine which components to hit
    @param bTraceComplex  True to test against complex collision, false to test against simplified collision.
    @param OutHit                 Properties of the trace hit.
    @return                               True if there was a hit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function LineTraceSingleByProfile(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, ProfileName : unreal.FName, bTraceComplex : Bool, ActorsToIgnore : unreal.Const<unreal.PRef<unreal.TArray<unreal.AActor>>>, DrawDebugType : unreal.EDrawDebugTrace, OutHit : unreal.PRef<unreal.FHitResult>, @:bpopt("true") bIgnoreSelf : Bool, @:opt("(R=1.000000,G=0.000000,B=0.000000,A=1.000000)") TraceColor : unreal.FLinearColor, @:opt("(R=0.000000,G=1.000000,B=0.000000,A=1.000000)") TraceHitColor : unreal.FLinearColor, DrawTime : unreal.Float32 = 5.000000) : Bool;

  /**
    Trace a ray against the world using a specific profile and return overlapping hits and then first blocking hit
    Results are sorted, so a blocking hit (if found) will be the last element of the array
    Only the single closest blocking result will be generated, no tests will be done after that

    @param WorldContext   World context
    @param Start                  Start of line segment.
    @param End                    End of line segment.
    @param ProfileName    The 'profile' used to determine which components to hit
    @param bTraceComplex  True to test against complex collision, false to test against simplified collision.
    @param OutHit         Properties of the trace hit.
    @return                               True if there was a blocking hit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function LineTraceMultiByProfile(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, ProfileName : unreal.FName, bTraceComplex : Bool, ActorsToIgnore : unreal.Const<unreal.PRef<unreal.TArray<unreal.AActor>>>, DrawDebugType : unreal.EDrawDebugTrace, OutHits : unreal.PRef<unreal.TArray<unreal.FHitResult>>, @:bpopt("true") bIgnoreSelf : Bool, @:opt("(R=1.000000,G=0.000000,B=0.000000,A=1.000000)") TraceColor : unreal.FLinearColor, @:opt("(R=0.000000,G=1.000000,B=0.000000,A=1.000000)") TraceHitColor : unreal.FLinearColor, DrawTime : unreal.Float32 = 5.000000) : Bool;

  /**
    Sweep a sphere against the world and return the first blocking hit using a specific profile

    @param Start                  Start of line segment.
    @param End                    End of line segment.
    @param Radius                 Radius of the sphere to sweep
    @param ProfileName    The 'profile' used to determine which components to hit
    @param bTraceComplex  True to test against complex collision, false to test against simplified collision.
    @param OutHit                 Properties of the trace hit.
    @return                               True if there was a hit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function SphereTraceSingleByProfile(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, Radius : unreal.Float32, ProfileName : unreal.FName, bTraceComplex : Bool, ActorsToIgnore : unreal.Const<unreal.PRef<unreal.TArray<unreal.AActor>>>, DrawDebugType : unreal.EDrawDebugTrace, OutHit : unreal.PRef<unreal.FHitResult>, @:bpopt("true") bIgnoreSelf : Bool, @:opt("(R=1.000000,G=0.000000,B=0.000000,A=1.000000)") TraceColor : unreal.FLinearColor, @:opt("(R=0.000000,G=1.000000,B=0.000000,A=1.000000)") TraceHitColor : unreal.FLinearColor, DrawTime : unreal.Float32 = 5.000000) : Bool;

  /**
    Sweep a sphere against the world and return all initial overlaps using a specific profile, then overlapping hits and then first blocking hit
    Results are sorted, so a blocking hit (if found) will be the last element of the array
    Only the single closest blocking result will be generated, no tests will be done after that

    @param WorldContext   World context
    @param Start                  Start of line segment.
    @param End                    End of line segment.
    @param Radius         Radius of the sphere to sweep
    @param ProfileName    The 'profile' used to determine which components to hit
    @param bTraceComplex  True to test against complex collision, false to test against simplified collision.
    @param OutHits                A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.
    @return                               True if there was a blocking hit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function SphereTraceMultiByProfile(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, Radius : unreal.Float32, ProfileName : unreal.FName, bTraceComplex : Bool, ActorsToIgnore : unreal.Const<unreal.PRef<unreal.TArray<unreal.AActor>>>, DrawDebugType : unreal.EDrawDebugTrace, OutHits : unreal.PRef<unreal.TArray<unreal.FHitResult>>, @:bpopt("true") bIgnoreSelf : Bool, @:opt("(R=1.000000,G=0.000000,B=0.000000,A=1.000000)") TraceColor : unreal.FLinearColor, @:opt("(R=0.000000,G=1.000000,B=0.000000,A=1.000000)") TraceHitColor : unreal.FLinearColor, DrawTime : unreal.Float32 = 5.000000) : Bool;

  /**
    Sweep a box against the world and return the first blocking hit using a specific profile

    @param Start                  Start of line segment.
    @param End                    End of line segment.
    @param HalfSize           Distance from the center of box along each axis
    @param Orientation    Orientation of the box
    @param ProfileName    The 'profile' used to determine which components to hit
    @param bTraceComplex  True to test against complex collision, false to test against simplified collision.
    @param OutHit                 Properties of the trace hit.
    @return                               True if there was a hit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function BoxTraceSingleByProfile(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, HalfSize : unreal.Const<unreal.FVector>, Orientation : unreal.Const<unreal.FRotator>, ProfileName : unreal.FName, bTraceComplex : Bool, ActorsToIgnore : unreal.Const<unreal.PRef<unreal.TArray<unreal.AActor>>>, DrawDebugType : unreal.EDrawDebugTrace, OutHit : unreal.PRef<unreal.FHitResult>, @:bpopt("true") bIgnoreSelf : Bool, @:opt("(R=1.000000,G=0.000000,B=0.000000,A=1.000000)") TraceColor : unreal.FLinearColor, @:opt("(R=0.000000,G=1.000000,B=0.000000,A=1.000000)") TraceHitColor : unreal.FLinearColor, DrawTime : unreal.Float32 = 5.000000) : Bool;

  /**
    Sweep a box against the world and return all initial overlaps using a specific profile, then overlapping hits and then first blocking hit
    Results are sorted, so a blocking hit (if found) will be the last element of the array
    Only the single closest blocking result will be generated, no tests will be done after that

    @param Start                  Start of line segment.
    @param End                    End of line segment.
    @param HalfSize           Distance from the center of box along each axis
    @param Orientation    Orientation of the box
    @param ProfileName    The 'profile' used to determine which components to hit
    @param bTraceComplex  True to test against complex collision, false to test against simplified collision.
    @param OutHits                A list of hits, sorted along the trace from start to finish. The blocking hit will be the last hit, if there was one.
    @return                               True if there was a blocking hit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function BoxTraceMultiByProfile(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, HalfSize : unreal.FVector, Orientation : unreal.Const<unreal.FRotator>, ProfileName : unreal.FName, bTraceComplex : Bool, ActorsToIgnore : unreal.Const<unreal.PRef<unreal.TArray<unreal.AActor>>>, DrawDebugType : unreal.EDrawDebugTrace, OutHits : unreal.PRef<unreal.TArray<unreal.FHitResult>>, @:bpopt("true") bIgnoreSelf : Bool, @:opt("(R=1.000000,G=0.000000,B=0.000000,A=1.000000)") TraceColor : unreal.FLinearColor, @:opt("(R=0.000000,G=1.000000,B=0.000000,A=1.000000)") TraceHitColor : unreal.FLinearColor, DrawTime : unreal.Float32 = 5.000000) : Bool;

  /**
    Sweep a capsule against the world and return the first blocking hit using a specific profile

    @param WorldContext   World context
    @param Start                  Start of line segment.
    @param End                    End of line segment.
    @param Radius                 Radius of the capsule to sweep
    @param HalfHeight             Distance from center of capsule to tip of hemisphere endcap.
    @param ProfileName    The 'profile' used to determine which components to hit
    @param bTraceComplex  True to test against complex collision, false to test against simplified collision.
    @param OutHit                 Properties of the trace hit.
    @return                               True if there was a hit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function CapsuleTraceSingleByProfile(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, Radius : unreal.Float32, HalfHeight : unreal.Float32, ProfileName : unreal.FName, bTraceComplex : Bool, ActorsToIgnore : unreal.Const<unreal.PRef<unreal.TArray<unreal.AActor>>>, DrawDebugType : unreal.EDrawDebugTrace, OutHit : unreal.PRef<unreal.FHitResult>, @:bpopt("true") bIgnoreSelf : Bool, @:opt("(R=1.000000,G=0.000000,B=0.000000,A=1.000000)") TraceColor : unreal.FLinearColor, @:opt("(R=0.000000,G=1.000000,B=0.000000,A=1.000000)") TraceHitColor : unreal.FLinearColor, DrawTime : unreal.Float32 = 5.000000) : Bool;

  /**
    Sweep a capsule against the world and return all initial overlaps using a specific profile, then overlapping hits and then first blocking hit
    Results are sorted, so a blocking hit (if found) will be the last element of the array
    Only the single closest blocking result will be generated, no tests will be done after that

    @param WorldContext   World context
    @param Start                  Start of line segment.
    @param End                    End of line segment.
    @param Radius                 Radius of the capsule to sweep
    @param HalfHeight             Distance from center of capsule to tip of hemisphere endcap.
    @param ProfileName    The 'profile' used to determine which components to hit
    @param bTraceComplex  True to test against complex collision, false to test against simplified collision.
    @param OutHits                A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.
    @return                               True if there was a blocking hit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function CapsuleTraceMultiByProfile(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, Radius : unreal.Float32, HalfHeight : unreal.Float32, ProfileName : unreal.FName, bTraceComplex : Bool, ActorsToIgnore : unreal.Const<unreal.PRef<unreal.TArray<unreal.AActor>>>, DrawDebugType : unreal.EDrawDebugTrace, OutHits : unreal.PRef<unreal.TArray<unreal.FHitResult>>, @:bpopt("true") bIgnoreSelf : Bool, @:opt("(R=1.000000,G=0.000000,B=0.000000,A=1.000000)") TraceColor : unreal.FLinearColor, @:opt("(R=0.000000,G=1.000000,B=0.000000,A=1.000000)") TraceHitColor : unreal.FLinearColor, DrawTime : unreal.Float32 = 5.000000) : Bool;

  /**
    Returns an array of unique actors represented by the given list of components.
    @param ComponentList         List of components.
    @param ClassFilter           If set, will only return results of this class or subclasses of it.
    @param OutActorList          Start of line segment.
  **/
  @:ufunction(BlueprintCallable) static public function GetActorListFromComponentList(ComponentList : unreal.Const<unreal.PRef<unreal.TArray<unreal.UPrimitiveComponent>>>, ActorClassFilter : unreal.UClass, OutActorList : unreal.PRef<unreal.TArray<unreal.AActor>>) : Void;

  /**
    Draw a debug line
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugLine(WorldContextObject : unreal.UObject, LineStart : unreal.Const<unreal.FVector>, LineEnd : unreal.Const<unreal.FVector>, LineColor : unreal.FLinearColor, Duration : unreal.Float32 = 0.000000, Thickness : unreal.Float32 = 0.000000) : Void;

  /**
    Draw a debug circle!
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugCircle(WorldContextObject : unreal.UObject, Center : unreal.FVector, Radius : unreal.Float32, NumSegments : unreal.Int32 = 12, @:opt("(R=1.000000,G=1.000000,B=1.000000,A=1.000000)") LineColor : unreal.FLinearColor, Duration : unreal.Float32 = 0.000000, Thickness : unreal.Float32 = 0.000000, @:opt("0.000000,1.000000,0.000000") YAxis : unreal.FVector, @:opt("0.000000,0.000000,1.000000") ZAxis : unreal.FVector, bDrawAxis : Bool = false) : Void;

  /**
    Draw a debug point
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugPoint(WorldContextObject : unreal.UObject, Position : unreal.Const<unreal.FVector>, Size : unreal.Float32, PointColor : unreal.FLinearColor, Duration : unreal.Float32 = 0.000000) : Void;

  /**
    Draw directional arrow, pointing from LineStart to LineEnd.
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugArrow(WorldContextObject : unreal.UObject, LineStart : unreal.Const<unreal.FVector>, LineEnd : unreal.Const<unreal.FVector>, ArrowSize : unreal.Float32, LineColor : unreal.FLinearColor, Duration : unreal.Float32 = 0.000000, Thickness : unreal.Float32 = 0.000000) : Void;

  /**
    Draw a debug box
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugBox(WorldContextObject : unreal.UObject, Center : unreal.Const<unreal.FVector>, Extent : unreal.FVector, LineColor : unreal.FLinearColor, Rotation : unreal.Const<unreal.FRotator>, Duration : unreal.Float32 = 0.000000, Thickness : unreal.Float32 = 0.000000) : Void;

  /**
    Draw a debug coordinate system.
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugCoordinateSystem(WorldContextObject : unreal.UObject, AxisLoc : unreal.Const<unreal.FVector>, AxisRot : unreal.Const<unreal.FRotator>, Scale : unreal.Float32 = 1.000000, Duration : unreal.Float32 = 0.000000, Thickness : unreal.Float32 = 0.000000) : Void;

  /**
    Draw a debug sphere
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugSphere(WorldContextObject : unreal.UObject, Center : unreal.Const<unreal.FVector>, Radius : unreal.Float32 = 100.000000, Segments : unreal.Int32 = 12, @:opt("(R=1.000000,G=1.000000,B=1.000000,A=1.000000)") LineColor : unreal.FLinearColor, Duration : unreal.Float32 = 0.000000, Thickness : unreal.Float32 = 0.000000) : Void;

  /**
    Draw a debug cylinder
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugCylinder(WorldContextObject : unreal.UObject, Start : unreal.Const<unreal.FVector>, End : unreal.Const<unreal.FVector>, Radius : unreal.Float32 = 100.000000, Segments : unreal.Int32 = 12, @:opt("(R=1.000000,G=1.000000,B=1.000000,A=1.000000)") LineColor : unreal.FLinearColor, Duration : unreal.Float32 = 0.000000, Thickness : unreal.Float32 = 0.000000) : Void;

  /**
    Draw a debug cone
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugCone(WorldContextObject : unreal.UObject, Origin : unreal.Const<unreal.FVector>, Direction : unreal.Const<unreal.FVector>, Length : unreal.Float32, AngleWidth : unreal.Float32, AngleHeight : unreal.Float32, NumSides : unreal.Int32, LineColor : unreal.FLinearColor, Duration : unreal.Float32 = 0.000000, Thickness : unreal.Float32 = 0.000000) : Void;

  /**
    Draw a debug cone
    Angles are specified in degrees
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugConeInDegrees(WorldContextObject : unreal.UObject, Origin : unreal.Const<unreal.FVector>, Direction : unreal.Const<unreal.FVector>, Length : unreal.Float32 = 100.000000, AngleWidth : unreal.Float32 = 45.000000, AngleHeight : unreal.Float32 = 45.000000, NumSides : unreal.Int32 = 12, @:opt("(R=1.000000,G=1.000000,B=1.000000,A=1.000000)") LineColor : unreal.FLinearColor, Duration : unreal.Float32 = 0.000000, Thickness : unreal.Float32 = 0.000000) : Void;

  /**
    Draw a debug capsule
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugCapsule(WorldContextObject : unreal.UObject, Center : unreal.Const<unreal.FVector>, HalfHeight : unreal.Float32, Radius : unreal.Float32, Rotation : unreal.Const<unreal.FRotator>, @:opt("(R=1.000000,G=1.000000,B=1.000000,A=1.000000)") LineColor : unreal.FLinearColor, Duration : unreal.Float32 = 0.000000, Thickness : unreal.Float32 = 0.000000) : Void;

  /**
    Draw a debug string at a 3d world location.
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugString(WorldContextObject : unreal.UObject, TextLocation : unreal.Const<unreal.FVector>, Text : unreal.FString, @:opt("None") TestBaseActor : unreal.AActor, @:opt("(R=1.000000,G=1.000000,B=1.000000,A=1.000000)") TextColor : unreal.FLinearColor, Duration : unreal.Float32 = 0.000000) : Void;

  /**
    Removes all debug strings.

    @param WorldContext  World context
  **/
  @:ufunction(BlueprintCallable) static public function FlushDebugStrings(WorldContextObject : unreal.UObject) : Void;

  /**
    Draws a debug plane.
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugPlane(WorldContextObject : unreal.UObject, PlaneCoordinates : unreal.Const<unreal.PRef<unreal.FPlane>>, Location : unreal.Const<unreal.FVector>, Size : unreal.Float32, @:opt("(R=1.000000,G=1.000000,B=1.000000,A=1.000000)") PlaneColor : unreal.FLinearColor, Duration : unreal.Float32 = 0.000000) : Void;

  /**
    Flush all persistent debug lines and shapes.

    @param WorldContext  World context
  **/
  @:ufunction(BlueprintCallable) static public function FlushPersistentDebugLines(WorldContextObject : unreal.UObject) : Void;

  /**
    Draws a debug frustum.
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugFrustum(WorldContextObject : unreal.UObject, FrustumTransform : unreal.Const<unreal.PRef<unreal.FTransform>>, @:opt("(R=1.000000,G=1.000000,B=1.000000,A=1.000000)") FrustumColor : unreal.FLinearColor, Duration : unreal.Float32 = 0.000000, Thickness : unreal.Float32 = 0.000000) : Void;

  /**
    Draw a debug camera shape.
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugCamera(CameraActor : unreal.Const<unreal.ACameraActor>, @:opt("(R=1.000000,G=1.000000,B=1.000000,A=1.000000)") CameraColor : unreal.FLinearColor, Duration : unreal.Float32 = 0.000000) : Void;

  /**
    Draws a 2D Histogram of size 'DrawSize' based FDebugFloatHistory struct, using DrawTransform for the position in the world.
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugFloatHistoryTransform(WorldContextObject : unreal.UObject, FloatHistory : unreal.Const<unreal.PRef<unreal.FDebugFloatHistory>>, DrawTransform : unreal.Const<unreal.PRef<unreal.FTransform>>, DrawSize : unreal.FVector2D, @:opt("(R=1.000000,G=1.000000,B=1.000000,A=1.000000)") DrawColor : unreal.FLinearColor, Duration : unreal.Float32 = 0.000000) : Void;

  /**
    Draws a 2D Histogram of size 'DrawSize' based FDebugFloatHistory struct, using DrawLocation for the location in the world, rotation will face camera of first player.
  **/
  @:ufunction(BlueprintCallable) static public function DrawDebugFloatHistoryLocation(WorldContextObject : unreal.UObject, FloatHistory : unreal.Const<unreal.PRef<unreal.FDebugFloatHistory>>, DrawLocation : unreal.FVector, DrawSize : unreal.FVector2D, @:opt("(R=1.000000,G=1.000000,B=1.000000,A=1.000000)") DrawColor : unreal.FLinearColor, Duration : unreal.Float32 = 0.000000) : Void;
  @:ufunction(BlueprintCallable) static public function AddFloatHistorySample(Value : unreal.Float32, FloatHistory : unreal.Const<unreal.PRef<unreal.FDebugFloatHistory>>) : unreal.FDebugFloatHistory;

  /**
    Mark as modified.
  **/
  @:ufunction(BlueprintCallable) static public function CreateCopyForUndoBuffer(ObjectToModify : unreal.UObject) : Void;

  /**
    Get bounds
  **/
  @:ufunction(BlueprintCallable) static public function GetComponentBounds(Component : unreal.Const<unreal.USceneComponent>, Origin : unreal.PRef<unreal.FVector>, BoxExtent : unreal.PRef<unreal.FVector>, SphereRadius : unreal.Float32) : Void;
  @:ufunction(BlueprintCallable) static public function GetActorBounds(Actor : unreal.Const<unreal.AActor>, Origin : unreal.PRef<unreal.FVector>, BoxExtent : unreal.PRef<unreal.FVector>) : Void;

  /**
    Get the clamped state of r.DetailMode, see console variable help (allows for scalability, cannot be used in construction scripts)
    0: low, show only object with DetailMode low or higher
    1: medium, show all object with DetailMode medium or higher
    2: high, show all objects
  **/
  @:ufunction(BlueprintCallable) static public function GetRenderingDetailMode() : unreal.Int32;

  /**
    Get the clamped state of r.MaterialQualityLevel, see console variable help (allows for scalability, cannot be used in construction scripts)
    0: low
    1: high
    2: medium
  **/
  @:ufunction(BlueprintCallable) static public function GetRenderingMaterialQualityLevel() : unreal.Int32;

  /**
    Gets the list of support fullscreen resolutions.
    @return true if successfully queried the device for available resolutions.
  **/
  @:ufunction(BlueprintCallable) static public function GetSupportedFullscreenResolutions(Resolutions : unreal.PRef<unreal.TArray<unreal.FIntPoint>>) : Bool;

  /**
    Gets the list of windowed resolutions which are convenient for the current primary display size.
    @return true if successfully queried the device for available resolutions.
  **/
  @:ufunction(BlueprintCallable) static public function GetConvenientWindowedResolutions(Resolutions : unreal.PRef<unreal.TArray<unreal.FIntPoint>>) : Bool;

  /**
    Gets the smallest Y resolution we want to support in the UI, clamped within reasons
    @return value in pixels
  **/
  @:ufunction(BlueprintCallable) static public function GetMinYResolutionForUI() : unreal.Int32;

  /**
    Gets the smallest Y resolution we want to support in the 3D view, clamped within reasons
    @return value in pixels
  **/
  @:ufunction(BlueprintCallable) static public function GetMinYResolutionFor3DView() : unreal.Int32;

  /**
    Opens the specified URL in the platform's web browser of choice
  **/
  @:ufunction(BlueprintCallable) static public function LaunchURL(URL : unreal.FString) : Void;
  @:ufunction(BlueprintCallable) static public function CanLaunchURL(URL : unreal.FString) : Bool;

  /**
    Deletes all unreferenced objects, keeping only referenced objects (this command will be queued and happen at the end of the frame)
    Note: This can be a slow operation, and should only be performed where a hitch would be acceptable
  **/
  @:ufunction(BlueprintCallable) static public function CollectGarbage() : Void;

  /**
    Will show an ad banner (iAd on iOS, or AdMob on Android) on the top or bottom of screen, on top of the GL view (doesn't resize the view)
    (iOS and Android only)

    @param AdIdIndex The index of the ID to select for the ad to show
    @param bShowOnBottomOfScreen If true, the iAd will be shown at the bottom of the screen, top otherwise
  **/
  @:ufunction(BlueprintCallable) static public function ShowAdBanner(AdIdIndex : unreal.Int32, bShowOnBottomOfScreen : Bool) : Void;

  /**
    Retrieves the total number of Ad IDs that can be selected between
  **/
  @:ufunction(BlueprintCallable) static public function GetAdIDCount() : unreal.Int32;

  /**
    Hides the ad banner (iAd on iOS, or AdMob on Android). Will force close the ad if it's open
    (iOS and Android only)
  **/
  @:ufunction(BlueprintCallable) static public function HideAdBanner() : Void;

  /**
    Forces closed any displayed ad. Can lead to loss of revenue
    (iOS and Android only)
  **/
  @:ufunction(BlueprintCallable) static public function ForceCloseAdBanner() : Void;

  /**
    Will load a fullscreen interstitial AdMob ad. Call this before using ShowInterstitialAd
    (Android only)

    @param AdIdIndex The index of the ID to select for the ad to show
  **/
  @:ufunction(BlueprintCallable) static public function LoadInterstitialAd(AdIdIndex : unreal.Int32) : Void;

  /**
    Returns true if the requested interstitial ad is loaded and ready
    (Android only)
  **/
  @:ufunction(BlueprintCallable) static public function IsInterstitialAdAvailable() : Bool;

  /**
    Returns true if the requested interstitial ad has been successfully requested (false if load request fails)
    (Android only)
  **/
  @:ufunction(BlueprintCallable) static public function IsInterstitialAdRequested() : Bool;

  /**
    Shows the loaded interstitial ad (loaded with LoadInterstitialAd)
    (Android only)
  **/
  @:ufunction(BlueprintCallable) static public function ShowInterstitialAd() : Void;

  /**
    Displays the built-in leaderboard GUI (iOS and Android only; this function may be renamed or moved in a future release)
  **/
  @:ufunction(BlueprintCallable) static public function ShowPlatformSpecificLeaderboardScreen(CategoryName : unreal.FString) : Void;

  /**
    Displays the built-in achievements GUI (iOS and Android only; this function may be renamed or moved in a future release)

    @param SpecificPlayer Specific player's achievements to show. May not be supported on all platforms. If null, defaults to the player with ControllerId 0
  **/
  @:ufunction(BlueprintCallable) static public function ShowPlatformSpecificAchievementsScreen(SpecificPlayer : unreal.APlayerController) : Void;

  /**
    Returns whether the player is logged in to the currently active online subsystem.

    @param Player Specific player's login status to get. May not be supported on all platforms. If null, defaults to the player with ControllerId 0.
  **/
  @:ufunction(BlueprintCallable) static public function IsLoggedIn(SpecificPlayer : unreal.APlayerController) : Bool;

  /**
    Returns true if screen saver is enabled.
  **/
  @:ufunction(BlueprintCallable) static public function IsScreensaverEnabled() : Bool;

  /**
    Allows or inhibits screensaver
    @param       bAllowScreenSaver               If false, don't allow screensaver if possible, otherwise allow default behavior
  **/
  @:ufunction(BlueprintCallable) static public function ControlScreensaver(bAllowScreenSaver : Bool) : Void;

  /**
    Allows or inhibits system default handling of volume up and volume down buttons (Android only)
    @param       bEnabled                                If true, allow Android to handle volume up and down events
  **/
  @:ufunction(BlueprintCallable) static public function SetVolumeButtonsHandledBySystem(bEnabled : Bool) : Void;

  /**
    Returns true if system default handling of volume up and volume down buttons enabled (Android only)
  **/
  @:ufunction(BlueprintCallable) static public function GetVolumeButtonsHandledBySystem() : Bool;

  /**
    Resets the gamepad to player controller id assignments (Android and iOS only)
  **/
  @:ufunction(BlueprintCallable) static public function ResetGamepadAssignments() : Void;

  /**
    * Resets the gamepad assignment to player controller id (Android and iOS only)
  **/
  @:ufunction(BlueprintCallable) static public function ResetGamepadAssignmentToController(ControllerId : unreal.Int32) : Void;

  /**
    Returns true if controller id assigned to a gamepad (Android and iOS only)
  **/
  @:ufunction(BlueprintCallable) static public function IsControllerAssignedToGamepad(ControllerId : unreal.Int32) : Bool;

  /**
    Returns name of controller if assigned to a gamepad (or None if not assigned) (Android and iOS only)
  **/
  @:ufunction(BlueprintCallable) static public function GetGamepadControllerName(ControllerId : unreal.Int32) : unreal.FString;

  /**
    Sets the state of the transition message rendered by the viewport. (The blue text displayed when the game is paused and so forth.)

    @param WorldContextObject    World context
    @param State                                 set true to suppress transition message
  **/
  @:ufunction(BlueprintCallable) static public function SetSuppressViewportTransitionMessage(WorldContextObject : unreal.UObject, bState : Bool) : Void;

  /**
    Returns an array of the user's preferred languages in order of preference
    @return An array of language IDs ordered from most preferred to least
  **/
  @:ufunction(BlueprintCallable) static public function GetPreferredLanguages() : unreal.TArray<unreal.FString>;

  /**
    Get the default language (for localization) used by this platform
    @note This is typically the same as GetDefaultLocale unless the platform distinguishes between the two
    @note This should be returned in IETF language tag form:
     - A two-letter ISO 639-1 language code (eg, "zh")
     - An optional four-letter ISO 15924 script code (eg, "Hans")
     - An optional two-letter ISO 3166-1 country code (eg, "CN")
    @return The language as an IETF language tag (eg, "zh-Hans-CN")
  **/
  @:ufunction(BlueprintCallable) static public function GetDefaultLanguage() : unreal.FString;

  /**
    Get the default locale (for internationalization) used by this platform
    @note This should be returned in IETF language tag form:
     - A two-letter ISO 639-1 language code (eg, "zh")
     - An optional four-letter ISO 15924 script code (eg, "Hans")
     - An optional two-letter ISO 3166-1 country code (eg, "CN")
    @return The locale as an IETF language tag (eg, "zh-Hans-CN")
  **/
  @:ufunction(BlueprintCallable) static public function GetDefaultLocale() : unreal.FString;

  /**
    Returns the currency code associated with the device's locale
    @return the currency code associated with the device's locale
  **/
  @:ufunction(BlueprintCallable) static public function GetLocalCurrencyCode() : unreal.FString;

  /**
    Returns the currency symbol associated with the device's locale
    @return the currency symbol associated with the device's locale
  **/
  @:ufunction(BlueprintCallable) static public function GetLocalCurrencySymbol() : unreal.FString;

  /**
    Requests permission to send remote notifications to the user's device.
    (Android and iOS only)
  **/
  @:ufunction(BlueprintCallable) static public function RegisterForRemoteNotifications() : Void;

  /**
    Requests Requests unregistering from receiving remote notifications to the user's device.
    (Android only)
  **/
  @:ufunction(BlueprintCallable) static public function UnregisterForRemoteNotifications() : Void;

  /**
    Tells the engine what the user is doing for debug, analytics, etc.
  **/
  @:ufunction(BlueprintCallable) static public function SetUserActivity(UserActivity : unreal.Const<unreal.PRef<unreal.FUserActivity>>) : Void;

  /**
    Returns the command line that the process was launched with.
  **/
  @:ufunction(BlueprintCallable) static public function GetCommandLine() : unreal.FString;

  /**
    Returns true if running unattended (-unattended is on the command line)

    @return      Unattended state
  **/
  @:ufunction(BlueprintCallable) static public function IsUnattended() : Bool;

  /**
    Begin a new undo transaction. An undo transaction is defined as all actions which take place when the user selects "undo" a single time.
    @note If there is already an active transaction in progress, then this increments that transaction's action counter instead of beginning a new transaction.
    @note You must call TransactObject before modifying each object that should be included in this undo transaction.
    @note Only available in the editor.

    @param       Context                 The context for the undo session. Typically the tool/editor that caused the undo operation.
    @param       Description             The description for the undo session. This is the text that will appear in the "Edit" menu next to the Undo item.
    @param       PrimaryObject   The primary object that the undo session operators on (can be null, and mostly is).

    @return      The number of active actions when BeginTransaction was called (values greater than 0 indicate that there was already an existing undo transaction in progress), or -1 on failure.
  **/
  @:ufunction(BlueprintCallable) static public function BeginTransaction(Context : unreal.FString, Description : unreal.FText, PrimaryObject : unreal.UObject) : unreal.Int32;

  /**
    Attempt to end the current undo transaction. Only successful if the transaction's action counter is 1.
    @note Only available in the editor.

    @return      The number of active actions when EndTransaction was called (a value of 1 indicates that the transaction was successfully closed), or -1 on failure.
  **/
  @:ufunction(BlueprintCallable) static public function EndTransaction() : unreal.Int32;

  /**
    Cancel the current transaction, and no longer capture actions to be placed in the undo buffer.
    @note Only available in the editor.

    @param       Index           The action counter to cancel transactions from (as returned by a call to BeginTransaction).
  **/
  @:ufunction(BlueprintCallable) static public function CancelTransaction(Index : unreal.Int32) : Void;

  /**
    Notify the current transaction (if any) that this object is about to be modified and should be placed into the undo buffer.
    @note Internally this calls Modify on the given object, so will also mark the owner package dirty.
    @note Only available in the editor.

    @param       Object          The object that is about to be modified.
  **/
  @:ufunction(BlueprintCallable) static public function TransactObject(Object : unreal.UObject) : Void;

  /**
    Returns the Object associated with a Primary Asset Id, this will only return a valid object if it is in memory, it will not load it
  **/
  @:ufunction(BlueprintCallable) static public function GetObjectFromPrimaryAssetId(PrimaryAssetId : unreal.FPrimaryAssetId) : unreal.UObject;

  /**
    Returns the Blueprint Class associated with a Primary Asset Id, this will only return a valid object if it is in memory, it will not load it
  **/
  @:ufunction(BlueprintCallable) static public function GetClassFromPrimaryAssetId(PrimaryAssetId : unreal.FPrimaryAssetId) : unreal.TSubclassOf<unreal.UObject>;

  /**
    Returns the Primary Asset Id for an Object, this can return an invalid one if not registered
  **/
  @:ufunction(BlueprintCallable) static public function GetPrimaryAssetIdFromObject(Object : unreal.UObject) : unreal.FPrimaryAssetId;

  /**
    Returns the Primary Asset Id for a Class, this can return an invalid one if not registered
  **/
  @:ufunction(BlueprintCallable) static public function GetPrimaryAssetIdFromClass(Class : unreal.TSubclassOf<unreal.UObject>) : unreal.FPrimaryAssetId;

  /**
    Returns list of PrimaryAssetIds for a PrimaryAssetType
  **/
  @:ufunction(BlueprintCallable) static public function GetPrimaryAssetIdList(PrimaryAssetType : unreal.FPrimaryAssetType, OutPrimaryAssetIdList : unreal.PRef<unreal.TArray<unreal.FPrimaryAssetId>>) : Void;

  /**
    Returns true if the Primary Asset Id is valid
  **/
  @:ufunction(BlueprintCallable) static public function IsValidPrimaryAssetId(PrimaryAssetId : unreal.FPrimaryAssetId) : Bool;

  /**
    Converts a Primary Asset Id to a string. The other direction is not provided because it cannot be validated
  **/
  @:ufunction(BlueprintCallable) static public function Conv_PrimaryAssetIdToString(PrimaryAssetId : unreal.FPrimaryAssetId) : unreal.FString;

  /**
    Returns true if the values are equal (A == B)
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_PrimaryAssetId(A : unreal.FPrimaryAssetId, B : unreal.FPrimaryAssetId) : Bool;

  /**
    Returns true if the values are not equal (A != B)
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_PrimaryAssetId(A : unreal.FPrimaryAssetId, B : unreal.FPrimaryAssetId) : Bool;

  /**
    Returns list of Primary Asset Ids for a PrimaryAssetType
  **/
  @:ufunction(BlueprintCallable) static public function IsValidPrimaryAssetType(PrimaryAssetType : unreal.FPrimaryAssetType) : Bool;

  /**
    Converts a Primary Asset Type to a string. The other direction is not provided because it cannot be validated
  **/
  @:ufunction(BlueprintCallable) static public function Conv_PrimaryAssetTypeToString(PrimaryAssetType : unreal.FPrimaryAssetType) : unreal.FString;

  /**
    Returns true if the values are equal (A == B)
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_PrimaryAssetType(A : unreal.FPrimaryAssetType, B : unreal.FPrimaryAssetType) : Bool;

  /**
    Returns true if the values are not equal (A != B)
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_PrimaryAssetType(A : unreal.FPrimaryAssetType, B : unreal.FPrimaryAssetType) : Bool;

  /**
    Unloads a primary asset, which allows it to be garbage collected if nothing else is referencing it
  **/
  @:ufunction(BlueprintCallable) static public function UnloadPrimaryAsset(PrimaryAssetId : unreal.FPrimaryAssetId) : Void;

  /**
    Unloads a primary asset, which allows it to be garbage collected if nothing else is referencing it
  **/
  @:ufunction(BlueprintCallable) static public function UnloadPrimaryAssetList(PrimaryAssetIdList : unreal.Const<unreal.PRef<unreal.TArray<unreal.FPrimaryAssetId>>>) : Void;

  /**
    Returns the list of loaded bundles for a given Primary Asset. This will return false if the asset is not loaded at all.
    If ForceCurrentState is true it will return the current state even if a load is in process
  **/
  @:ufunction(BlueprintCallable) static public function GetCurrentBundleState(PrimaryAssetId : unreal.FPrimaryAssetId, bForceCurrentState : Bool, OutBundles : unreal.PRef<unreal.TArray<unreal.FName>>) : Bool;

  /**
    Returns the list of assets that are in a given bundle state. Required Bundles must be specified
    If ExcludedBundles is not empty, it will not return any assets in those bundle states
    If ValidTypes is not empty, it will only return assets of those types
    If ForceCurrentState is true it will use the current state even if a load is in process
  **/
  @:ufunction(BlueprintCallable) static public function GetPrimaryAssetsWithBundleState(RequiredBundles : unreal.Const<unreal.PRef<unreal.TArray<unreal.FName>>>, ExcludedBundles : unreal.Const<unreal.PRef<unreal.TArray<unreal.FName>>>, ValidTypes : unreal.Const<unreal.PRef<unreal.TArray<unreal.FPrimaryAssetType>>>, bForceCurrentState : Bool, OutPrimaryAssetIdList : unreal.PRef<unreal.TArray<unreal.FPrimaryAssetId>>) : Void;

}
