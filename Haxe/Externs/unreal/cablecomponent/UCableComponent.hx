/**
   * 
   * WARNING! This file was autogenerated by: 
   *  _   _ _____     ___   _   _ __   __ 
   * | | | |  ___|   /   | | | | |\ \ / / 
   * | | | | |__    / /| | | |_| | \ V /  
   * | | | |  __|  / /_| | |  _  | /   \  
   * | |_| | |___  \___  | | | | |/ /^\ \ 
   *  \___/\____/      |_/ \_| |_/\/   \/ 
   * 
   * This file was autogenerated by UE4HaxeExternGenerator using UHT definitions. It only includes UPROPERTYs and UFUNCTIONs. Do not modify it!
   * In order to add more definitions, create or edit a type with the same name/package, but with an `_Extra` suffix
**/
package unreal.cablecomponent;


/**
  Component that allows you to specify custom triangle mesh geometry
**/
@:umodule("CableComponent")
@:glueCppIncludes("CableComponent.h")
@:uextern extern class UCableComponent extends unreal.UMeshComponent {
  
  /**
    How many times to repeat the material along the length of the cable
  **/
  public var TileMaterial : unreal.Float32;
  
  /**
    Number of sides of the cable geometry
  **/
  public var NumSides : unreal.Int32;
  
  /**
    How wide the cable geometry is
  **/
  public var CableWidth : unreal.Float32;
  
  /**
    Scaling applied to world gravity affecting this cable.
  **/
  public var CableGravityScale : unreal.Float32;
  
  /**
    Force vector (world space) applied to all particles in cable.
  **/
  public var CableForce : unreal.FVector;
  
  /**
    If collision is enabled, control how much sliding friction is applied when cable is in contact.
  **/
  public var CollisionFriction : unreal.Float32;
  
  /**
    EXPERIMENTAL. Perform sweeps for each cable particle, each substep, to avoid collisions with the world.
    Uses the Collision Preset on the component to determine what is collided with.
    This greatly increases the cost of the cable simulation.
  **/
  public var bEnableCollision : Bool;
  
  /**
    Add stiffness constraints to cable.
  **/
  public var bEnableStiffness : Bool;
  
  /**
    The number of solver iterations controls how 'stiff' the cable is
  **/
  public var SolverIterations : unreal.Int32;
  
  /**
    Controls the simulation substep time for the cable
  **/
  public var SubstepTime : unreal.Float32;
  
  /**
    How many segments the cable has
  **/
  public var NumSegments : unreal.Int32;
  
  /**
    Rest length of the cable
  **/
  public var CableLength : unreal.Float32;
  
  /**
    End location of cable, relative to AttachEndTo (or AttachEndToSocketName) if specified, otherwise relative to cable component.
  **/
  public var EndLocation : unreal.FVector;
  
  /**
    Socket name on the AttachEndTo component to attach to
  **/
  public var AttachEndToSocketName : unreal.FName;
  
  /**
    Actor or Component that the defines the end position of the cable
  **/
  public var AttachEndTo : unreal.FComponentReference;
  
  /**
    Should we fix the end to something (using AttachEndTo and EndLocation), or leave it free.
    If false, AttachEndTo and EndLocation are just used for initial location of end of cable
  **/
  public var bAttachEnd : Bool;
  
  /**
    Should we fix the start to something, or leave it free.
    If false, component transform is just used for initial location of start of cable
  **/
  public var bAttachStart : Bool;
  
  /**
    Attaches the end of the cable to a specific Component within an Actor *
  **/
  @:final public function SetAttachEndTo(Actor : unreal.AActor, ComponentProperty : unreal.FName, SocketName : unreal.FName) : Void;
  
  /**
    Gets the Actor that the cable is attached to *
  **/
  @:thisConst @:final public function GetAttachedActor() : unreal.AActor;
  
  /**
    Gets the specific USceneComponent that the cable is attached to *
  **/
  @:thisConst @:final public function GetAttachedComponent() : unreal.USceneComponent;
  
  /**
    Get array of locations of particles (in world space) making up the cable simulation.
  **/
  @:thisConst @:final public function GetCableParticleLocations(Locations : unreal.PRef<unreal.TArray<unreal.FVector>>) : Void;
  
}
