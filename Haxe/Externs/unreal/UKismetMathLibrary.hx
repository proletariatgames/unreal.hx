/**
   * 
   * WARNING! This file was autogenerated by: 
   *  _   _ _____     ___   _   _ __   __ 
   * | | | |  ___|   /   | | | | |\ \ / / 
   * | | | | |__    / /| | | |_| | \ V /  
   * | | | |  __|  / /_| | |  _  | /   \  
   * | |_| | |___  \___  | | | | |/ /^\ \ 
   *  \___/\____/      |_/ \_| |_/\/   \/ 
   * 
   * This file was autogenerated by UE4HaxeExternGenerator using UHT definitions. It only includes UPROPERTYs and UFUNCTIONs. Do not modify it!
   * In order to add more definitions, create or edit a type with the same name/package, but with an `_Extra` suffix
**/
package unreal;

@:glueCppIncludes("Kismet/KismetMathLibrary.h")
@:uextern extern class UKismetMathLibrary extends unreal.UBlueprintFunctionLibrary {
  
  /**
    Returns a uniformly distributed random bool
  **/
  static public function RandomBool() : Bool;
  
  /**
    Get a random chance with the specified weight. Range of weight is 0.0 - 1.0 E.g.,
                 Weight = .6 return value = True 60% of the time
  **/
  static public function RandomBoolWithWeight(Weight : unreal.Float32) : Bool;
  
  /**
    Get a random chance with the specified weight. Range of weight is 0.0 - 1.0 E.g.,
                  Weight = .6 return value = True 60% of the time
  **/
  static public function RandomBoolWithWeightFromStream(Weight : unreal.Float32, RandomStream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : Bool;
  
  /**
    Returns the logical complement of the Boolean value (NOT A)
  **/
  static public function Not_PreBool(A : Bool) : Bool;
  
  /**
    Returns true if the values are equal (A == B)
  **/
  static public function EqualEqual_BoolBool(A : Bool, B : Bool) : Bool;
  
  /**
    Returns true if the values are not equal (A != B)
  **/
  static public function NotEqual_BoolBool(A : Bool, B : Bool) : Bool;
  
  /**
    Returns the logical AND of two values (A AND B)
  **/
  static public function BooleanAND(A : Bool, B : Bool) : Bool;
  
  /**
    Returns the logical NAND of two values (A AND B)
  **/
  static public function BooleanNAND(A : Bool, B : Bool) : Bool;
  
  /**
    Returns the logical OR of two values (A OR B)
  **/
  static public function BooleanOR(A : Bool, B : Bool) : Bool;
  
  /**
    Returns the logical eXclusive OR of two values (A XOR B)
  **/
  static public function BooleanXOR(A : Bool, B : Bool) : Bool;
  
  /**
    Returns the logical Not OR of two values (A NOR B)
  **/
  static public function BooleanNOR(A : Bool, B : Bool) : Bool;
  
  /**
    Multiplication (A * B)
  **/
  static public function Multiply_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : unreal.UInt8;
  
  /**
    Division (A / B)
  **/
  static public function Divide_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : unreal.UInt8;
  
  /**
    Modulo (A % B)
  **/
  static public function Percent_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : unreal.UInt8;
  
  /**
    Addition (A + B)
  **/
  static public function Add_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : unreal.UInt8;
  
  /**
    Subtraction (A - B)
  **/
  static public function Subtract_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : unreal.UInt8;
  
  /**
    Returns the minimum value of A and B
  **/
  static public function BMin(A : unreal.UInt8, B : unreal.UInt8) : unreal.UInt8;
  
  /**
    Returns the maximum value of A and B
  **/
  static public function BMax(A : unreal.UInt8, B : unreal.UInt8) : unreal.UInt8;
  
  /**
    Returns true if A is less than B (A < B)
  **/
  static public function Less_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : Bool;
  
  /**
    Returns true if A is greater than B (A > B)
  **/
  static public function Greater_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : Bool;
  
  /**
    Returns true if A is less than or equal to B (A <= B)
  **/
  static public function LessEqual_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : Bool;
  
  /**
    Returns true if A is greater than or equal to B (A >= B)
  **/
  static public function GreaterEqual_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : Bool;
  
  /**
    Returns true if A is equal to B (A == B)
  **/
  static public function EqualEqual_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : Bool;
  
  /**
    Returns true if A is not equal to B (A != B)
  **/
  static public function NotEqual_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : Bool;
  
  /**
    Multiplication (A * B)
  **/
  static public function Multiply_IntInt(A : unreal.Int32, B : unreal.Int32) : unreal.Int32;
  
  /**
    Division (A / B)
  **/
  static public function Divide_IntInt(A : unreal.Int32, B : unreal.Int32) : unreal.Int32;
  
  /**
    Modulo (A % B)
  **/
  static public function Percent_IntInt(A : unreal.Int32, B : unreal.Int32) : unreal.Int32;
  
  /**
    Addition (A + B)
  **/
  static public function Add_IntInt(A : unreal.Int32, B : unreal.Int32) : unreal.Int32;
  
  /**
    Subtraction (A - B)
  **/
  static public function Subtract_IntInt(A : unreal.Int32, B : unreal.Int32) : unreal.Int32;
  
  /**
    Returns true if A is less than B (A < B)
  **/
  static public function Less_IntInt(A : unreal.Int32, B : unreal.Int32) : Bool;
  
  /**
    Returns true if A is greater than B (A > B)
  **/
  static public function Greater_IntInt(A : unreal.Int32, B : unreal.Int32) : Bool;
  
  /**
    Returns true if A is less than or equal to B (A <= B)
  **/
  static public function LessEqual_IntInt(A : unreal.Int32, B : unreal.Int32) : Bool;
  
  /**
    Returns true if A is greater than or equal to B (A >= B)
  **/
  static public function GreaterEqual_IntInt(A : unreal.Int32, B : unreal.Int32) : Bool;
  
  /**
    Returns true if A is equal to B (A == B)
  **/
  static public function EqualEqual_IntInt(A : unreal.Int32, B : unreal.Int32) : Bool;
  
  /**
    Returns true if A is not equal to B (A != B)
  **/
  static public function NotEqual_IntInt(A : unreal.Int32, B : unreal.Int32) : Bool;
  
  /**
    Bitwise AND (A & B)
  **/
  static public function And_IntInt(A : unreal.Int32, B : unreal.Int32) : unreal.Int32;
  
  /**
    Bitwise XOR (A ^ B)
  **/
  static public function Xor_IntInt(A : unreal.Int32, B : unreal.Int32) : unreal.Int32;
  
  /**
    Bitwise OR (A | B)
  **/
  static public function Or_IntInt(A : unreal.Int32, B : unreal.Int32) : unreal.Int32;
  
  /**
    Bitwise NOT (~A)
  **/
  static public function Not_Int(A : unreal.Int32) : unreal.Int32;
  
  /**
    Sign (integer, returns -1 if A < 0, 0 if A is zero, and +1 if A > 0)
  **/
  static public function SignOfInteger(A : unreal.Int32) : unreal.Int32;
  
  /**
    Returns a uniformly distributed random number between 0 and Max - 1
  **/
  static public function RandomInteger(Max : unreal.Int32) : unreal.Int32;
  
  /**
    Return a random integer between Min and Max (>= Min and <= Max)
  **/
  static public function RandomIntegerInRange(Min : unreal.Int32, Max : unreal.Int32) : unreal.Int32;
  
  /**
    Returns the minimum value of A and B
  **/
  static public function Min(A : unreal.Int32, B : unreal.Int32) : unreal.Int32;
  
  /**
    Returns the maximum value of A and B
  **/
  static public function Max(A : unreal.Int32, B : unreal.Int32) : unreal.Int32;
  
  /**
    Returns Value clamped to be between A and B (inclusive)
  **/
  static public function Clamp(Value : unreal.Int32, Min : unreal.Int32, Max : unreal.Int32) : unreal.Int32;
  
  /**
    Returns the absolute (positive) value of A
  **/
  static public function Abs_Int(A : unreal.Int32) : unreal.Int32;
  
  /**
    Power (Base to the Exp-th power)
  **/
  static public function MultiplyMultiply_FloatFloat(Base : unreal.Float32, Exp : unreal.Float32) : unreal.Float32;
  
  /**
    Multiplication (A * B)
  **/
  static public function Multiply_FloatFloat(A : unreal.Float32, B : unreal.Float32) : unreal.Float32;
  
  /**
    Multiplication (A * B)
  **/
  static public function Multiply_IntFloat(A : unreal.Int32, B : unreal.Float32) : unreal.Float32;
  
  /**
    Division (A / B)
  **/
  static public function Divide_FloatFloat(A : unreal.Float32, B : unreal.Float32) : unreal.Float32;
  
  /**
    Modulo (A % B)
  **/
  static public function Percent_FloatFloat(A : unreal.Float32, B : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the fractional part of a float.
  **/
  static public function Fraction(A : unreal.Float32) : unreal.Float32;
  
  /**
    Addition (A + B)
  **/
  static public function Add_FloatFloat(A : unreal.Float32, B : unreal.Float32) : unreal.Float32;
  
  /**
    Subtraction (A - B)
  **/
  static public function Subtract_FloatFloat(A : unreal.Float32, B : unreal.Float32) : unreal.Float32;
  
  /**
    Returns true if A is Less than B (A < B)
  **/
  static public function Less_FloatFloat(A : unreal.Float32, B : unreal.Float32) : Bool;
  
  /**
    Returns true if A is greater than B (A > B)
  **/
  static public function Greater_FloatFloat(A : unreal.Float32, B : unreal.Float32) : Bool;
  
  /**
    Returns true if A is Less than or equal to B (A <= B)
  **/
  static public function LessEqual_FloatFloat(A : unreal.Float32, B : unreal.Float32) : Bool;
  
  /**
    Returns true if A is greater than or equal to B (A >= B)
  **/
  static public function GreaterEqual_FloatFloat(A : unreal.Float32, B : unreal.Float32) : Bool;
  
  /**
    Returns true if A is exactly equal to B (A == B)
  **/
  static public function EqualEqual_FloatFloat(A : unreal.Float32, B : unreal.Float32) : Bool;
  
  /**
    Returns true if A is nearly equal to B (|A - B| < ErrorTolerance)
  **/
  static public function NearlyEqual_FloatFloat(A : unreal.Float32, B : unreal.Float32, ErrorTolerance : unreal.Float32) : Bool;
  
  /**
    Returns true if A does not equal B (A != B)
  **/
  static public function NotEqual_FloatFloat(A : unreal.Float32, B : unreal.Float32) : Bool;
  
  /**
    Returns V clamped to be between A and B (inclusive)
  **/
  static public function InRange_FloatFloat(Value : unreal.Float32, Min : unreal.Float32, Max : unreal.Float32, InclusiveMin : Bool, InclusiveMax : Bool) : Bool;
  
  /**
    Returns the hypotenuse of a right-angled triangle given the width and height.
  **/
  static public function Hypotenuse(Width : unreal.Float32, Height : unreal.Float32) : unreal.Float32;
  
  /**
    Snaps a value to the nearest grid multiple. E.g.,
                Location = 5.1, GridSize = 10.0 : return value = 10.0
    If GridSize is 0 Location is returned
    if GridSize is very small precision issues may occur.
  **/
  static public function GridSnap_Float(Location : unreal.Float32, GridSize : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the absolute (positive) value of A
  **/
  static public function Abs(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the sine of A (expects Radians)
  **/
  static public function Sin(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the inverse sine (arcsin) of A (result is in Radians)
  **/
  static public function Asin(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the cosine of A (expects Radians)
  **/
  static public function Cos(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the inverse cosine (arccos) of A (result is in Radians)
  **/
  static public function Acos(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the tan of A (expects Radians)
  **/
  static public function Tan(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the inverse tan (atan) (result is in Radians)
  **/
  static public function Atan(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the inverse tan (atan2) of A/B (result is in Radians)
  **/
  static public function Atan2(A : unreal.Float32, B : unreal.Float32) : unreal.Float32;
  
  /**
    Returns exponential(e) to the power A (e^A)
  **/
  static public function Exp(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns natural log of A (if e^R == A, returns R)
  **/
  static public function Loge(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns square root of A
  **/
  static public function Sqrt(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns square of A (A*A)
  **/
  static public function Square(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns a random float between 0 and 1
  **/
  static public function RandomFloat() : unreal.Float32;
  
  /**
    Generate a random number between Min and Max
  **/
  static public function RandomFloatInRange(Min : unreal.Float32, Max : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the value of PI
  **/
  static public function GetPI() : unreal.Float32;
  
  /**
    Returns the value of TAU (= 2 * PI)
  **/
  static public function GetTAU() : unreal.Float32;
  
  /**
    Returns radians value based on the input degrees
  **/
  static public function DegreesToRadians(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns degrees value based on the input radians
  **/
  static public function RadiansToDegrees(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the sin of A (expects Degrees)
  **/
  static public function DegSin(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the inverse sin (arcsin) of A (result is in Degrees)
  **/
  static public function DegAsin(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the cos of A (expects Degrees)
  **/
  static public function DegCos(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the inverse cos (arccos) of A (result is in Degrees)
  **/
  static public function DegAcos(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the tan of A (expects Degrees)
  **/
  static public function DegTan(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the inverse tan (atan) (result is in Degrees)
  **/
  static public function DegAtan(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the inverse tan (atan2) of A/B (result is in Degrees)
  **/
  static public function DegAtan2(A : unreal.Float32, B : unreal.Float32) : unreal.Float32;
  
  /**
    Clamps an arbitrary angle to be between the given angles.  Will clamp to nearest boundary.
    
    @param MinAngleDegrees       "from" angle that defines the beginning of the range of valid angles (sweeping clockwise)
    @param MaxAngleDegrees       "to" angle that defines the end of the range of valid angles
    @return Returns clamped angle in the range -180..180.
  **/
  static public function ClampAngle(AngleDegrees : unreal.Float32, MinAngleDegrees : unreal.Float32, MaxAngleDegrees : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the minimum value of A and B
  **/
  static public function FMin(A : unreal.Float32, B : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the maximum value of A and B
  **/
  static public function FMax(A : unreal.Float32, B : unreal.Float32) : unreal.Float32;
  
  /**
    Returns V clamped to be between A and B (inclusive)
  **/
  static public function FClamp(Value : unreal.Float32, Min : unreal.Float32, Max : unreal.Float32) : unreal.Float32;
  
  /**
    Returns max of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.
  **/
  static public function MaxOfIntArray(IntArray : unreal.Const<unreal.PRef<unreal.TArray<unreal.Int32>>>, IndexOfMaxValue : unreal.Int32, MaxValue : unreal.Int32) : Void;
  
  /**
    Returns min of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.
  **/
  static public function MinOfIntArray(IntArray : unreal.Const<unreal.PRef<unreal.TArray<unreal.Int32>>>, IndexOfMinValue : unreal.Int32, MinValue : unreal.Int32) : Void;
  
  /**
    Returns max of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.
  **/
  static public function MaxOfFloatArray(FloatArray : unreal.Const<unreal.PRef<unreal.TArray<unreal.Float32>>>, IndexOfMaxValue : unreal.Int32, MaxValue : unreal.Float32) : Void;
  
  /**
    Returns min of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.
  **/
  static public function MinOfFloatArray(FloatArray : unreal.Const<unreal.PRef<unreal.TArray<unreal.Float32>>>, IndexOfMinValue : unreal.Int32, MinValue : unreal.Float32) : Void;
  
  /**
    Returns max of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.
  **/
  static public function MaxOfByteArray(ByteArray : unreal.Const<unreal.PRef<unreal.TArray<unreal.UInt8>>>, IndexOfMaxValue : unreal.Int32, MaxValue : unreal.UInt8) : Void;
  
  /**
    Returns min of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.
  **/
  static public function MinOfByteArray(ByteArray : unreal.Const<unreal.PRef<unreal.TArray<unreal.UInt8>>>, IndexOfMinValue : unreal.Int32, MinValue : unreal.UInt8) : Void;
  
  /**
    Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)
  **/
  static public function Lerp(A : unreal.Float32, B : unreal.Float32, Alpha : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the percentage of the range B-A that corresponds to Value. E.g.,
          A = 0, B = 8, Value = 3 : return value = 3/8, indicating Value is 3/8 from A to B
          A = 8, B = 0, Value = 3 : return value = 5/8, indicating Value is 5/8 from A to B
    Named InverseLerp because Lerp( A, B, InverseLerp(A, B, Value) ) == Value
    @param A The "from" value this float could be, usually but not necessarily a minimum. Returned as 0.
    @param B The "to" value this float could be, usually but not necessarily a maximum. Returned as 1.
    @param Value A value intended to be normalized relative to B-A
    @return A normalized value considering A and B.
  **/
  static public function InverseLerp(A : unreal.Float32, B : unreal.Float32, Value : unreal.Float32) : unreal.Float32;
  
  /**
    Easeing  between A and B using a specified easing function
  **/
  static public function Ease(A : unreal.Float32, B : unreal.Float32, Alpha : unreal.Float32, EasingFunc : unreal.EEasingFunc, BlendExp : unreal.Float32, Steps : unreal.Int32) : unreal.Float32;
  
  /**
    Rounds A to the nearest integer
  **/
  static public function Round(A : unreal.Float32) : unreal.Int32;
  
  /**
    Rounds A to the largest previous integer
  **/
  static public function FFloor(A : unreal.Float32) : unreal.Int32;
  
  /**
    Rounds A to an integer with truncation towards zero.  (e.g. -1.7 truncated to -1, 2.8 truncated to 2)
  **/
  static public function FTrunc(A : unreal.Float32) : unreal.Int32;
  
  /**
    Rounds A to the smallest following integer
  **/
  static public function FCeil(A : unreal.Float32) : unreal.Int32;
  
  /**
    Returns the number of times Divisor will go into Dividend (i.e., Dividend divided by Divisor), as well as the remainder
  **/
  static public function FMod(Dividend : unreal.Float32, Divisor : unreal.Float32, Remainder : unreal.Float32) : unreal.Int32;
  
  /**
    Sign (float, returns -1 if A < 0, 0 if A is zero, and +1 if A > 0)
  **/
  static public function SignOfFloat(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns Value normalized to the given range.  (e.g. 20 normalized to the range 10->50 would result in 0.25)
  **/
  static public function NormalizeToRange(Value : unreal.Float32, RangeMin : unreal.Float32, RangeMax : unreal.Float32) : unreal.Float32;
  
  /**
    Returns Value mapped from one range into another.  (e.g. 20 normalized from the range 10->50 to 20->40 would result in 25)
  **/
  static public function MapRangeUnclamped(Value : unreal.Float32, InRangeA : unreal.Float32, InRangeB : unreal.Float32, OutRangeA : unreal.Float32, OutRangeB : unreal.Float32) : unreal.Float32;
  
  /**
    Returns Value mapped from one range into another where the Value is clamped to the Input Range.  (e.g. 0.5 normalized from the range 0->1 to 0->50 would result in 25)
  **/
  static public function MapRangeClamped(Value : unreal.Float32, InRangeA : unreal.Float32, InRangeB : unreal.Float32, OutRangeA : unreal.Float32, OutRangeB : unreal.Float32) : unreal.Float32;
  
  /**
    Multiplies the input value by pi.
  **/
  static public function MultiplyByPi(Value : unreal.Float32) : unreal.Float32;
  
  /**
    Interpolate between A and B, applying an ease in/out function.  Exp controls the degree of the curve.
  **/
  static public function FInterpEaseInOut(A : unreal.Float32, B : unreal.Float32, Alpha : unreal.Float32, Exponent : unreal.Float32) : unreal.Float32;
  
  /**
    Simple function to create a pulsating scalar value
    
    @param  InCurrentTime  Current absolute time
    @param  InPulsesPerSecond  How many full pulses per second?
    @param  InPhase  Optional phase amount, between 0.0 and 1.0 (to synchronize pulses)
    
    @return  Pulsating value (0.0-1.0)
  **/
  static public function MakePulsatingValue(InCurrentTime : unreal.Float32, InPulsesPerSecond : unreal.Float32, InPhase : unreal.Float32) : unreal.Float32;
  
  /**
    Returns a new rotation component value
    
    @param InCurrent is the current rotation value
    @param InDesired is the desired rotation value
    @param  is the rotation amount to apply
    
    @return a new rotation component value clamped in the range (-360,360)
  **/
  static public function FixedTurn(InCurrent : unreal.Float32, InDesired : unreal.Float32, InDeltaRate : unreal.Float32) : unreal.Float32;
  
  /**
    Scales Vector A by B
  **/
  static public function Multiply_VectorFloat(A : unreal.FVector, B : unreal.Float32) : unreal.FVector;
  
  /**
    Scales Vector A by B
  **/
  static public function Multiply_VectorInt(A : unreal.FVector, B : unreal.Int32) : unreal.FVector;
  
  /**
    Element-wise Vector multiplication (Result = {A.x*B.x, A.y*B.y, A.z*B.z})
  **/
  static public function Multiply_VectorVector(A : unreal.FVector, B : unreal.FVector) : unreal.FVector;
  
  /**
    Vector divide by a float
  **/
  static public function Divide_VectorFloat(A : unreal.FVector, B : unreal.Float32) : unreal.FVector;
  
  /**
    Vector divide by an integer
  **/
  static public function Divide_VectorInt(A : unreal.FVector, B : unreal.Int32) : unreal.FVector;
  
  /**
    Vector divide by vector
  **/
  static public function Divide_VectorVector(A : unreal.FVector, B : unreal.FVector) : unreal.FVector;
  
  /**
    Vector addition
  **/
  static public function Add_VectorVector(A : unreal.FVector, B : unreal.FVector) : unreal.FVector;
  
  /**
    Adds a float to each component of a vector
  **/
  static public function Add_VectorFloat(A : unreal.FVector, B : unreal.Float32) : unreal.FVector;
  
  /**
    Adds an integer to each component of a vector
  **/
  static public function Add_VectorInt(A : unreal.FVector, B : unreal.Int32) : unreal.FVector;
  
  /**
    Vector subtraction
  **/
  static public function Subtract_VectorVector(A : unreal.FVector, B : unreal.FVector) : unreal.FVector;
  
  /**
    Subtracts a float from each component of a vector
  **/
  static public function Subtract_VectorFloat(A : unreal.FVector, B : unreal.Float32) : unreal.FVector;
  
  /**
    Subtracts an integer from each component of a vector
  **/
  static public function Subtract_VectorInt(A : unreal.FVector, B : unreal.Int32) : unreal.FVector;
  
  /**
    Returns result of vector A rotated by the inverse of Rotator B
  **/
  static public function LessLess_VectorRotator(A : unreal.FVector, B : unreal.FRotator) : unreal.FVector;
  
  /**
    Returns result of vector A rotated by Rotator B
  **/
  static public function GreaterGreater_VectorRotator(A : unreal.FVector, B : unreal.FRotator) : unreal.FVector;
  
  /**
    Returns result of vector A rotated by AngleDeg around Axis
  **/
  static public function RotateAngleAxis(InVect : unreal.FVector, AngleDeg : unreal.Float32, Axis : unreal.FVector) : unreal.FVector;
  
  /**
    Returns true if vector A is equal to vector B (A == B) within a specified error tolerance
  **/
  static public function EqualEqual_VectorVector(A : unreal.FVector, B : unreal.FVector, ErrorTolerance : unreal.Float32) : Bool;
  
  /**
    Returns true if vector A is not equal to vector B (A != B) within a specified error tolerance
  **/
  static public function NotEqual_VectorVector(A : unreal.FVector, B : unreal.FVector, ErrorTolerance : unreal.Float32) : Bool;
  
  /**
    Returns the dot product of two 3d vectors
  **/
  static public function Dot_VectorVector(A : unreal.FVector, B : unreal.FVector) : unreal.Float32;
  
  /**
    Returns the cross product of two 3d vectors
  **/
  static public function Cross_VectorVector(A : unreal.FVector, B : unreal.FVector) : unreal.FVector;
  
  /**
    Returns the dot product of two 2d vectors
  **/
  static public function DotProduct2D(A : unreal.FVector2D, B : unreal.FVector2D) : unreal.Float32;
  
  /**
    Returns the cross product of two 2d vectors
  **/
  static public function CrossProduct2D(A : unreal.FVector2D, B : unreal.FVector2D) : unreal.Float32;
  
  /**
    Returns the length of the FVector
  **/
  static public function VSize(A : unreal.FVector) : unreal.Float32;
  
  /**
    Returns the length of a 2d FVector.
  **/
  static public function VSize2D(A : unreal.FVector2D) : unreal.Float32;
  
  /**
    Returns the squared length of the FVector
  **/
  static public function VSizeSquared(A : unreal.FVector) : unreal.Float32;
  
  /**
    Returns the squared length of a 2d FVector.
  **/
  static public function VSize2DSquared(A : unreal.FVector2D) : unreal.Float32;
  
  /**
    Returns a unit normal version of the FVector A
  **/
  static public function Normal(A : unreal.FVector) : unreal.FVector;
  
  /**
    Returns a unit normal version of the vector2d A
  **/
  static public function Normal2D(A : unreal.FVector2D) : unreal.FVector2D;
  
  /**
    Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)
  **/
  static public function VLerp(A : unreal.FVector, B : unreal.FVector, Alpha : unreal.Float32) : unreal.FVector;
  
  /**
    Easeing  between A and B using a specified easing function
  **/
  static public function VEase(A : unreal.FVector, B : unreal.FVector, Alpha : unreal.Float32, EasingFunc : unreal.EEasingFunc, BlendExp : unreal.Float32, Steps : unreal.Int32) : unreal.FVector;
  
  /**
    Returns a random vector with length of 1
  **/
  static public function RandomUnitVector() : unreal.FVector;
  
  /**
    Returns a random point within the specified bounding box
  **/
  static public function RandomPointInBoundingBox(Origin : unreal.Const<unreal.PRef<unreal.FVector>>, BoxExtent : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FVector;
  
  /**
    Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
    @param ConeDir       The base "center" direction of the cone.
    @param ConeHalfAngle         The half-angle of the cone (from ConeDir to edge), in radians.
  **/
  static public function RandomUnitVectorInCone(ConeDir : unreal.FVector, ConeHalfAngle : unreal.Float32) : unreal.FVector;
  
  /**
    RandomUnitVectorWithYawAndPitch
    
    @param MaxYaw - The Yaw-angle of the cone (from ConeDir to horizontal-edge), in degrees.
    @param MaxPitch - The Pitch-angle of the cone (from ConeDir to vertical-edge), in degrees.
  **/
  static public function RandomUnitVectorInConeWithYawAndPitch(ConeDir : unreal.FVector, MaxYawInDegrees : unreal.Float32, MaxPitchInDegrees : unreal.Float32) : unreal.FVector;
  
  /**
    Mirrors a vector by a normal
  **/
  static public function MirrorVectorByNormal(InVect : unreal.FVector, InNormal : unreal.FVector) : unreal.FVector;
  
  /**
    Projects one vector (V) onto another (Target) and returns the projected vector.
    If Target is nearly zero in length, returns the zero vector.
    
    @param  V Vector to project.
    @param  Target Vector on which we are projecting.
    @return V projected on to Target.
  **/
  static public function ProjectVectorOnToVector(V : unreal.FVector, Target : unreal.FVector) : unreal.FVector;
  
  /**
    Find closest points between 2 segments.
    
    @param       Segment1Start   Start of the 1st segment.
    @param       Segment1End             End of the 1st segment.
    @param       Segment2Start   Start of the 2nd segment.
    @param       Segment2End             End of the 2nd segment.
    @param       Segment1Point   Closest point on segment 1 to segment 2.
    @param       Segment2Point   Closest point on segment 2 to segment 1.
  **/
  static public function FindNearestPointsOnLineSegments(Segment1Start : unreal.FVector, Segment1End : unreal.FVector, Segment2Start : unreal.FVector, Segment2End : unreal.FVector, Segment1Point : unreal.PRef<unreal.FVector>, Segment2Point : unreal.PRef<unreal.FVector>) : Void;
  
  /**
    Find the closest point on a segment to a given point.
    
    @param Point                 Point for which we find the closest point on the segment.
    @param SegmentStart  Start of the segment.
    @param SegmentEnd    End of the segment.
    @return The closest point on the segment to the given point.
  **/
  static public function FindClosestPointOnSegment(Point : unreal.FVector, SegmentStart : unreal.FVector, SegmentEnd : unreal.FVector) : unreal.FVector;
  
  /**
    Find the closest point on an infinite line to a given point.
    
    @param Point                 Point for which we find the closest point on the line.
    @param LineOrigin    Point of reference on the line.
    @param LineDirection Direction of the line. Not required to be normalized.
    @return The closest point on the line to the given point.
  **/
  static public function FindClosestPointOnLine(Point : unreal.FVector, LineOrigin : unreal.FVector, LineDirection : unreal.FVector) : unreal.FVector;
  
  /**
    Find the distance from a point to the closest point on a segment.
    
    @param Point                  Point for which we find the distance to the closest point on the segment.
    @param SegmentStart   Start of the segment.
    @param SegmentEnd             End of the segment.
    @return The distance from the given point to the closest point on the segment.
  **/
  static public function GetPointDistanceToSegment(Point : unreal.FVector, SegmentStart : unreal.FVector, SegmentEnd : unreal.FVector) : unreal.Float32;
  
  /**
    Find the distance from a point to the closest point on an infinite line.
    
    @param Point                  Point for which we find the distance to the closest point on the line.
    @param LineOrigin             Point of reference on the line.
    @param LineDirection  Direction of the line. Not required to be normalized.
    @return The distance from the given point to the closest point on the line.
  **/
  static public function GetPointDistanceToLine(Point : unreal.FVector, LineOrigin : unreal.FVector, LineDirection : unreal.FVector) : unreal.Float32;
  
  /**
    Projects a point onto a plane defined by a point on the plane and a plane normal.
    
    @param  Point Point to project onto the plane.
    @param  PlaneBase A point on the plane.
    @param  PlaneNormal Normal of the plane.
    @return Point projected onto the plane.
  **/
  static public function ProjectPointOnToPlane(Point : unreal.FVector, PlaneBase : unreal.FVector, PlaneNormal : unreal.FVector) : unreal.FVector;
  
  /**
    Projects a vector onto a plane defined by a normalized vector (PlaneNormal).
    
    @param  V Vector to project onto the plane.
    @param  PlaneNormal Normal of the plane.
    @return Vector projected onto the plane.
  **/
  static public function ProjectVectorOnToPlane(V : unreal.FVector, PlaneNormal : unreal.FVector) : unreal.FVector;
  
  /**
    Negate a vector.
  **/
  static public function NegateVector(A : unreal.FVector) : unreal.FVector;
  
  /**
    Clamp the vector size between a min and max length
  **/
  static public function ClampVectorSize(A : unreal.FVector, Min : unreal.Float32, Max : unreal.Float32) : unreal.FVector;
  
  /**
    Find the minimum element (X, Y or Z) of a vector
  **/
  static public function GetMinElement(A : unreal.FVector) : unreal.Float32;
  
  /**
    Find the maximum element (X, Y or Z) of a vector
  **/
  static public function GetMaxElement(A : unreal.FVector) : unreal.Float32;
  
  /**
    Find the average of an array of vectors
  **/
  static public function GetVectorArrayAverage(Vectors : unreal.Const<unreal.PRef<unreal.TArray<unreal.FVector>>>) : unreal.FVector;
  
  /**
    Find the unit direction vector from one position to another.
  **/
  static public function GetDirectionUnitVector(From : unreal.FVector, To : unreal.FVector) : unreal.FVector;
  
  /**
    Returns true if rotator A is equal to rotator B (A == B) within a specified error tolerance
  **/
  static public function EqualEqual_RotatorRotator(A : unreal.FRotator, B : unreal.FRotator, ErrorTolerance : unreal.Float32) : Bool;
  
  /**
    Returns true if rotator A is not equal to rotator B (A != B) within a specified error tolerance
  **/
  static public function NotEqual_RotatorRotator(A : unreal.FRotator, B : unreal.FRotator, ErrorTolerance : unreal.Float32) : Bool;
  
  /**
    Returns rotator representing rotator A scaled by B
  **/
  static public function Multiply_RotatorFloat(A : unreal.FRotator, B : unreal.Float32) : unreal.FRotator;
  
  /**
    Returns rotator representing rotator A scaled by B
  **/
  static public function Multiply_RotatorInt(A : unreal.FRotator, B : unreal.Int32) : unreal.FRotator;
  
  /**
    Combine 2 rotations to give you the resulting rotation
  **/
  static public function ComposeRotators(A : unreal.FRotator, B : unreal.FRotator) : unreal.FRotator;
  
  /**
    Negate a rotator
  **/
  static public function NegateRotator(A : unreal.FRotator) : unreal.FRotator;
  
  /**
    Get the reference frame direction vectors (axes) described by this rotation
  **/
  static public function GetAxes(A : unreal.FRotator, X : unreal.PRef<unreal.FVector>, Y : unreal.PRef<unreal.FVector>, Z : unreal.PRef<unreal.FVector>) : Void;
  
  /**
    Generates a random rotation, with optional random roll.
  **/
  static public function RandomRotator(bRoll : Bool) : unreal.FRotator;
  
  /**
    Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)
  **/
  static public function RLerp(A : unreal.FRotator, B : unreal.FRotator, Alpha : unreal.Float32, bShortestPath : Bool) : unreal.FRotator;
  
  /**
    Easeing  between A and B using a specified easing function
  **/
  static public function REase(A : unreal.FRotator, B : unreal.FRotator, Alpha : unreal.Float32, bShortestPath : Bool, EasingFunc : unreal.EEasingFunc, BlendExp : unreal.Float32, Steps : unreal.Int32) : unreal.FRotator;
  
  /**
    Normalized A-B
  **/
  static public function NormalizedDeltaRotator(A : unreal.FRotator, B : unreal.FRotator) : unreal.FRotator;
  
  /**
    Create a rotation from an axis and and angle (in degrees)
  **/
  static public function RotatorFromAxisAndAngle(Axis : unreal.FVector, Angle : unreal.Float32) : unreal.FRotator;
  
  /**
    Clamps an angle to the range of [0, 360].
    
    @param Angle The angle to clamp.
    @return The clamped angle.
  **/
  static public function ClampAxis(Angle : unreal.Float32) : unreal.Float32;
  
  /**
    Clamps an angle to the range of [-180, 180].
    
    @param Angle The Angle to clamp.
    @return The clamped angle.
  **/
  static public function NormalizeAxis(Angle : unreal.Float32) : unreal.Float32;
  
  /**
    Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)
  **/
  static public function LinearColorLerp(A : unreal.FLinearColor, B : unreal.FLinearColor, Alpha : unreal.Float32) : unreal.FLinearColor;
  
  /**
    Linearly interpolates between two colors by the specified Alpha amount (100% of A when Alpha=0 and 100% of B when Alpha=1).  The interpolation is performed in HSV color space taking the shortest path to the new color's hue.  This can give better results than a normal lerp, but is much more expensive.  The incoming colors are in RGB space, and the output color will be RGB.  The alpha value will also be interpolated.
    
    @param       A               The color and alpha to interpolate from as linear RGBA
    @param       B               The color and alpha to interpolate to as linear RGBA
    @param       Alpha   Scalar interpolation amount (usually between 0.0 and 1.0 inclusive)
    
    @return      The interpolated color in linear RGB space along with the interpolated alpha value
  **/
  static public function LinearColorLerpUsingHSV(A : unreal.FLinearColor, B : unreal.FLinearColor, Alpha : unreal.Float32) : unreal.FLinearColor;
  
  /**
    Element-wise multiplication of two linear colors (R*R, G*G, B*B, A*A)
  **/
  static public function Multiply_LinearColorLinearColor(A : unreal.FLinearColor, B : unreal.FLinearColor) : unreal.FLinearColor;
  
  /**
    Element-wise multiplication of a linear color by a float (F*R, F*G, F*B, F*A)
  **/
  static public function Multiply_LinearColorFloat(A : unreal.FLinearColor, B : unreal.Float32) : unreal.FLinearColor;
  
  /**
    Creates a plane with a facing direction of Normal at the given Point
    
    @param Point  A point on the plane
    @param Normal  The Normal of the plane at Point
    @return Plane instance
  **/
  static public function MakePlaneFromPointAndNormal(Point : unreal.FVector, Normal : unreal.FVector) : unreal.FPlane;
  
  /**
    Makes a DateTime struct
  **/
  static public function MakeDateTime(Year : unreal.Int32, Month : unreal.Int32, Day : unreal.Int32, Hour : unreal.Int32, Minute : unreal.Int32, Second : unreal.Int32, Millisecond : unreal.Int32) : unreal.FDateTime;
  
  /**
    Breaks a DateTime into its components
  **/
  static public function BreakDateTime(InDateTime : unreal.FDateTime, Year : unreal.Int32, Month : unreal.Int32, Day : unreal.Int32, Hour : unreal.Int32, Minute : unreal.Int32, Second : unreal.Int32, Millisecond : unreal.Int32) : Void;
  
  /**
    Addition (A + B)
  **/
  static public function Add_DateTimeTimespan(A : unreal.FDateTime, B : unreal.FTimespan) : unreal.FDateTime;
  
  /**
    Subtraction (A - B)
  **/
  static public function Subtract_DateTimeTimespan(A : unreal.FDateTime, B : unreal.FTimespan) : unreal.FDateTime;
  
  /**
    Subtraction (A - B)
  **/
  static public function Subtract_DateTimeDateTime(A : unreal.FDateTime, B : unreal.FDateTime) : unreal.FTimespan;
  
  /**
    Returns true if the values are equal (A == B)
  **/
  static public function EqualEqual_DateTimeDateTime(A : unreal.FDateTime, B : unreal.FDateTime) : Bool;
  
  /**
    Returns true if the values are not equal (A != B)
  **/
  static public function NotEqual_DateTimeDateTime(A : unreal.FDateTime, B : unreal.FDateTime) : Bool;
  
  /**
    Returns true if A is greater than B (A > B)
  **/
  static public function Greater_DateTimeDateTime(A : unreal.FDateTime, B : unreal.FDateTime) : Bool;
  
  /**
    Returns true if A is greater than or equal to B (A >= B)
  **/
  static public function GreaterEqual_DateTimeDateTime(A : unreal.FDateTime, B : unreal.FDateTime) : Bool;
  
  /**
    Returns true if A is less than B (A < B)
  **/
  static public function Less_DateTimeDateTime(A : unreal.FDateTime, B : unreal.FDateTime) : Bool;
  
  /**
    Returns true if A is less than or equal to B (A <= B)
  **/
  static public function LessEqual_DateTimeDateTime(A : unreal.FDateTime, B : unreal.FDateTime) : Bool;
  
  /**
    Returns the date component of A
  **/
  static public function GetDate(A : unreal.FDateTime) : unreal.FDateTime;
  
  /**
    Returns the day component of A (1 to 31)
  **/
  static public function GetDay(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns the day of year of A
  **/
  static public function GetDayOfYear(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns the hour component of A (24h format)
  **/
  static public function GetHour(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns the hour component of A (12h format)
  **/
  static public function GetHour12(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns the millisecond component of A
  **/
  static public function GetMillisecond(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns the minute component of A
  **/
  static public function GetMinute(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns the month component of A
  **/
  static public function GetMonth(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns the second component of A
  **/
  static public function GetSecond(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns the time elapsed since midnight of A
  **/
  static public function GetTimeOfDay(A : unreal.FDateTime) : unreal.FTimespan;
  
  /**
    Returns the year component of A
  **/
  static public function GetYear(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns whether A's time is in the afternoon
  **/
  static public function IsAfternoon(A : unreal.FDateTime) : Bool;
  
  /**
    Returns whether A's time is in the morning
  **/
  static public function IsMorning(A : unreal.FDateTime) : Bool;
  
  /**
    Returns the number of days in the given year and month
  **/
  static public function DaysInMonth(Year : unreal.Int32, Month : unreal.Int32) : unreal.Int32;
  
  /**
    Returns the number of days in the given year
  **/
  static public function DaysInYear(Year : unreal.Int32) : unreal.Int32;
  
  /**
    Returns whether given year is a leap year
  **/
  static public function IsLeapYear(Year : unreal.Int32) : Bool;
  
  /**
    Returns the maximum date and time value
  **/
  static public function DateTimeMaxValue() : unreal.FDateTime;
  
  /**
    Returns the minimum date and time value
  **/
  static public function DateTimeMinValue() : unreal.FDateTime;
  
  /**
    Returns the local date and time on this computer
  **/
  static public function Now() : unreal.FDateTime;
  
  /**
    Returns the local date on this computer
  **/
  static public function Today() : unreal.FDateTime;
  
  /**
    Returns the UTC date and time on this computer
  **/
  static public function UtcNow() : unreal.FDateTime;
  
  /**
    Converts a date string in ISO-8601 format to a DateTime object
  **/
  static public function DateTimeFromIsoString(IsoString : unreal.FString, Result : unreal.PRef<unreal.FDateTime>) : Bool;
  
  /**
    Converts a date string to a DateTime object
  **/
  static public function DateTimeFromString(DateTimeString : unreal.FString, Result : unreal.PRef<unreal.FDateTime>) : Bool;
  
  /**
    Makes a Timespan struct
  **/
  static public function MakeTimespan(Days : unreal.Int32, Hours : unreal.Int32, Minutes : unreal.Int32, Seconds : unreal.Int32, Milliseconds : unreal.Int32) : unreal.FTimespan;
  
  /**
    Breaks a Timespan into its components
  **/
  static public function BreakTimespan(InTimespan : unreal.FTimespan, Days : unreal.Int32, Hours : unreal.Int32, Minutes : unreal.Int32, Seconds : unreal.Int32, Milliseconds : unreal.Int32) : Void;
  
  /**
    Addition (A + B)
  **/
  static public function Add_TimespanTimespan(A : unreal.FTimespan, B : unreal.FTimespan) : unreal.FTimespan;
  
  /**
    Subtraction (A - B)
  **/
  static public function Subtract_TimespanTimespan(A : unreal.FTimespan, B : unreal.FTimespan) : unreal.FTimespan;
  
  /**
    Scalar multiplication (A * s)
  **/
  static public function Multiply_TimespanFloat(A : unreal.FTimespan, Scalar : unreal.Float32) : unreal.FTimespan;
  
  /**
    Returns true if the values are equal (A == B)
  **/
  static public function EqualEqual_TimespanTimespan(A : unreal.FTimespan, B : unreal.FTimespan) : Bool;
  
  /**
    Returns true if the values are not equal (A != B)
  **/
  static public function NotEqual_TimespanTimespan(A : unreal.FTimespan, B : unreal.FTimespan) : Bool;
  
  /**
    Returns true if A is greater than B (A > B)
  **/
  static public function Greater_TimespanTimespan(A : unreal.FTimespan, B : unreal.FTimespan) : Bool;
  
  /**
    Returns true if A is greater than or equal to B (A >= B)
  **/
  static public function GreaterEqual_TimespanTimespan(A : unreal.FTimespan, B : unreal.FTimespan) : Bool;
  
  /**
    Returns true if A is less than B (A < B)
  **/
  static public function Less_TimespanTimespan(A : unreal.FTimespan, B : unreal.FTimespan) : Bool;
  
  /**
    Returns true if A is less than or equal to B (A <= B)
  **/
  static public function LessEqual_TimespanTimespan(A : unreal.FTimespan, B : unreal.FTimespan) : Bool;
  
  /**
    Returns the days component of A
  **/
  static public function GetDays(A : unreal.FTimespan) : unreal.Int32;
  
  /**
    Returns the absolute value of A
  **/
  static public function GetDuration(A : unreal.FTimespan) : unreal.FTimespan;
  
  /**
    Returns the hours component of A
  **/
  static public function GetHours(A : unreal.FTimespan) : unreal.Int32;
  
  /**
    Returns the milliseconds component of A
  **/
  static public function GetMilliseconds(A : unreal.FTimespan) : unreal.Int32;
  
  /**
    Returns the minutes component of A
  **/
  static public function GetMinutes(A : unreal.FTimespan) : unreal.Int32;
  
  /**
    Returns the seconds component of A
  **/
  static public function GetSeconds(A : unreal.FTimespan) : unreal.Int32;
  
  /**
    Returns the total number of days in A
  **/
  static public function GetTotalDays(A : unreal.FTimespan) : unreal.Float32;
  
  /**
    Returns the total number of hours in A
  **/
  static public function GetTotalHours(A : unreal.FTimespan) : unreal.Float32;
  
  /**
    Returns the total number of milliseconds in A
  **/
  static public function GetTotalMilliseconds(A : unreal.FTimespan) : unreal.Float32;
  
  /**
    Returns the total number of minutes in A
  **/
  static public function GetTotalMinutes(A : unreal.FTimespan) : unreal.Float32;
  
  /**
    Returns the total number of seconds in A
  **/
  static public function GetTotalSeconds(A : unreal.FTimespan) : unreal.Float32;
  
  /**
    Returns a time span that represents the specified number of days
  **/
  static public function FromDays(Days : unreal.Float32) : unreal.FTimespan;
  
  /**
    Returns a time span that represents the specified number of hours
  **/
  static public function FromHours(Hours : unreal.Float32) : unreal.FTimespan;
  
  /**
    Returns a time span that represents the specified number of milliseconds
  **/
  static public function FromMilliseconds(Milliseconds : unreal.Float32) : unreal.FTimespan;
  
  /**
    Returns a time span that represents the specified number of minutes
  **/
  static public function FromMinutes(Minutes : unreal.Float32) : unreal.FTimespan;
  
  /**
    Returns a time span that represents the specified number of seconds
  **/
  static public function FromSeconds(Seconds : unreal.Float32) : unreal.FTimespan;
  
  /**
    Returns the maximum time span value
  **/
  static public function TimespanMaxValue() : unreal.FTimespan;
  
  /**
    Returns the minimum time span value
  **/
  static public function TimespanMinValue() : unreal.FTimespan;
  
  /**
    Returns the ratio between two time spans (A / B), handles zero values
  **/
  static public function TimespanRatio(A : unreal.FTimespan, B : unreal.FTimespan) : unreal.Float32;
  
  /**
    Returns a zero time span value
  **/
  static public function TimespanZeroValue() : unreal.FTimespan;
  
  /**
    Converts a time span string to a Timespan object
  **/
  static public function TimespanFromString(TimespanString : unreal.FString, Result : unreal.PRef<unreal.FTimespan>) : Bool;
  
  /**
    Converts a byte to a float
  **/
  static public function Conv_ByteToFloat(InByte : unreal.UInt8) : unreal.Float32;
  
  /**
    Converts an integer to a float
  **/
  static public function Conv_IntToFloat(InInt : unreal.Int32) : unreal.Float32;
  
  /**
    Converts an integer to a byte (if the integer is too large, returns the low 8 bits)
  **/
  static public function Conv_IntToByte(InInt : unreal.Int32) : unreal.UInt8;
  
  /**
    Converts a int to a bool
  **/
  static public function Conv_IntToBool(InInt : unreal.Int32) : Bool;
  
  /**
    Converts a bool to an int
  **/
  static public function Conv_BoolToInt(InBool : Bool) : unreal.Int32;
  
  /**
    Converts a bool to a float (0.0f or 1.0f)
  **/
  static public function Conv_BoolToFloat(InBool : Bool) : unreal.Float32;
  
  /**
    Converts a bool to a byte
  **/
  static public function Conv_BoolToByte(InBool : Bool) : unreal.UInt8;
  
  /**
    Converts a byte to an integer
  **/
  static public function Conv_ByteToInt(InByte : unreal.UInt8) : unreal.Int32;
  
  /**
    Converts a vector to LinearColor
  **/
  static public function Conv_VectorToLinearColor(InVec : unreal.FVector) : unreal.FLinearColor;
  
  /**
    Converts a LinearColor to a vector
  **/
  static public function Conv_LinearColorToVector(InLinearColor : unreal.FLinearColor) : unreal.FVector;
  
  /**
    Converts a color to LinearColor
  **/
  static public function Conv_ColorToLinearColor(InColor : unreal.FColor) : unreal.FLinearColor;
  
  /**
    Converts a LinearColor to a color
  **/
  static public function Conv_LinearColorToColor(InLinearColor : unreal.FLinearColor) : unreal.FColor;
  
  /**
    Convert a vector to a transform. Uses vector as location
  **/
  static public function Conv_VectorToTransform(InLocation : unreal.FVector) : unreal.FTransform;
  
  /**
    Convert a Vector to a Vector2D
  **/
  static public function Conv_VectorToVector2D(InVector : unreal.FVector) : unreal.FVector2D;
  
  /**
    Convert a Vector2D to a Vector
  **/
  static public function Conv_Vector2DToVector(InVector2D : unreal.FVector2D, Z : unreal.Float32) : unreal.FVector;
  
  /**
    Convert a float into a vector, where each element is that float
  **/
  static public function Conv_FloatToVector(InFloat : unreal.Float32) : unreal.FVector;
  
  /**
    Convert a float into a LinearColor, where each element is that float
  **/
  static public function Conv_FloatToLinearColor(InFloat : unreal.Float32) : unreal.FLinearColor;
  
  /**
    Makes a vector {X, Y, Z}
  **/
  static public function MakeVector(X : unreal.Float32, Y : unreal.Float32, Z : unreal.Float32) : unreal.FVector;
  
  /**
    Breaks a vector apart into X, Y, Z
  **/
  static public function BreakVector(InVec : unreal.FVector, X : unreal.Float32, Y : unreal.Float32, Z : unreal.Float32) : Void;
  
  /**
    Makes a 2d vector {X, Y}
  **/
  static public function MakeVector2D(X : unreal.Float32, Y : unreal.Float32) : unreal.FVector2D;
  
  /**
    Breaks a 2D vector apart into X, Y.
  **/
  static public function BreakVector2D(InVec : unreal.FVector2D, X : unreal.Float32, Y : unreal.Float32) : Void;
  
  /**
    Rotate the world forward vector by the given rotation
  **/
  static public function GetForwardVector(InRot : unreal.FRotator) : unreal.FVector;
  
  /**
    Rotate the world right vector by the given rotation
  **/
  static public function GetRightVector(InRot : unreal.FRotator) : unreal.FVector;
  
  /**
    Rotate the world up vector by the given rotation
  **/
  static public function GetUpVector(InRot : unreal.FRotator) : unreal.FVector;
  
  /**
    Creates a directional vector from rotation values {Pitch, Yaw} supplied in degrees with specified Length
  **/
  static public function CreateVectorFromYawPitch(Yaw : unreal.Float32, Pitch : unreal.Float32, Length : unreal.Float32) : unreal.FVector;
  
  /**
    Breaks a vector apart into Yaw, Pitch rotation values given in degrees. (non-clamped)
  **/
  static public function GetYawPitchFromVector(InVec : unreal.FVector, Yaw : unreal.Float32, Pitch : unreal.Float32) : Void;
  
  /**
    Makes a rotator {Roll, Pitch, Yaw} from rotation values supplied in degrees
  **/
  static public function MakeRotator(Roll : unreal.Float32, Pitch : unreal.Float32, Yaw : unreal.Float32) : unreal.FRotator;
  
  /**
    Find a rotation for an object at Start location to point at Target location.
  **/
  static public function FindLookAtRotation(Start : unreal.Const<unreal.PRef<unreal.FVector>>, Target : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a rotator given only a XAxis. Y and Z are unspecified but will be orthonormal. XAxis need not be normalized.
  **/
  static public function MakeRotFromX(X : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a rotation matrix given only a YAxis. X and Z are unspecified but will be orthonormal. YAxis need not be normalized.
  **/
  static public function MakeRotFromY(Y : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a rotation matrix given only a ZAxis. X and Y are unspecified but will be orthonormal. ZAxis need not be normalized.
  **/
  static public function MakeRotFromZ(Z : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a matrix with given X and Y axes. X will remain fixed, Y may be changed minimally to enforce orthogonality. Z will be computed. Inputs need not be normalized.
  **/
  static public function MakeRotFromXY(X : unreal.Const<unreal.PRef<unreal.FVector>>, Y : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a matrix with given X and Z axes. X will remain fixed, Z may be changed minimally to enforce orthogonality. Y will be computed. Inputs need not be normalized.
  **/
  static public function MakeRotFromXZ(X : unreal.Const<unreal.PRef<unreal.FVector>>, Z : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a matrix with given Y and X axes. Y will remain fixed, X may be changed minimally to enforce orthogonality. Z will be computed. Inputs need not be normalized.
  **/
  static public function MakeRotFromYX(Y : unreal.Const<unreal.PRef<unreal.FVector>>, X : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a matrix with given Y and Z axes. Y will remain fixed, Z may be changed minimally to enforce orthogonality. X will be computed. Inputs need not be normalized.
  **/
  static public function MakeRotFromYZ(Y : unreal.Const<unreal.PRef<unreal.FVector>>, Z : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a matrix with given Z and X axes. Z will remain fixed, X may be changed minimally to enforce orthogonality. Y will be computed. Inputs need not be normalized.
  **/
  static public function MakeRotFromZX(Z : unreal.Const<unreal.PRef<unreal.FVector>>, X : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a matrix with given Z and Y axes. Z will remain fixed, Y may be changed minimally to enforce orthogonality. X will be computed. Inputs need not be normalized.
  **/
  static public function MakeRotFromZY(Z : unreal.Const<unreal.PRef<unreal.FVector>>, Y : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Breaks apart a rotator into {Roll, Pitch, Yaw} angles in degrees
  **/
  static public function BreakRotator(InRot : unreal.FRotator, Roll : unreal.Float32, Pitch : unreal.Float32, Yaw : unreal.Float32) : Void;
  
  /**
    Breaks apart a rotator into its component axes
  **/
  static public function BreakRotIntoAxes(InRot : unreal.Const<unreal.PRef<unreal.FRotator>>, X : unreal.PRef<unreal.FVector>, Y : unreal.PRef<unreal.FVector>, Z : unreal.PRef<unreal.FVector>) : Void;
  
  /**
    Make a transform from location, rotation and scale
  **/
  static public function MakeTransform(Location : unreal.FVector, Rotation : unreal.FRotator, Scale : unreal.FVector) : unreal.FTransform;
  
  /**
    Breaks apart a transform into location, rotation and scale
  **/
  static public function BreakTransform(InTransform : unreal.Const<unreal.PRef<unreal.FTransform>>, Location : unreal.PRef<unreal.FVector>, Rotation : unreal.PRef<unreal.FRotator>, Scale : unreal.PRef<unreal.FVector>) : Void;
  
  /**
    Makes a SRand-based random number generator
  **/
  static public function MakeRandomStream(InitialSeed : unreal.Int32) : unreal.FRandomStream;
  
  /**
    Breaks apart a random number generator
  **/
  static public function BreakRandomStream(InRandomStream : unreal.Const<unreal.PRef<unreal.FRandomStream>>, InitialSeed : unreal.Int32) : Void;
  
  /**
    Make a color from individual color components (RGB space)
  **/
  static public function MakeColor(R : unreal.Float32, G : unreal.Float32, B : unreal.Float32, A : unreal.Float32) : unreal.FLinearColor;
  
  /**
    Breaks apart a color into individual RGB components (as well as alpha)
  **/
  static public function BreakColor(InColor : unreal.Const<unreal.FLinearColor>, R : unreal.Float32, G : unreal.Float32, B : unreal.Float32, A : unreal.Float32) : Void;
  
  /**
    Make a color from individual color components (HSV space)
  **/
  static public function HSVToRGB(H : unreal.Float32, S : unreal.Float32, V : unreal.Float32, A : unreal.Float32) : unreal.FLinearColor;
  
  /**
    Breaks apart a color into individual HSV components (as well as alpha)
  **/
  static public function RGBToHSV(InColor : unreal.Const<unreal.FLinearColor>, H : unreal.Float32, S : unreal.Float32, V : unreal.Float32, A : unreal.Float32) : Void;
  
  /**
    Converts a HSV linear color (where H is in R, S is in G, and V is in B) to RGB
  **/
  static public function HSVToRGB_Vector(HSV : unreal.Const<unreal.FLinearColor>, RGB : unreal.PRef<unreal.FLinearColor>) : Void;
  
  /**
    Converts a RGB linear color to HSV (where H is in R, S is in G, and V is in B)
  **/
  static public function RGBToHSV_Vector(RGB : unreal.Const<unreal.FLinearColor>, HSV : unreal.PRef<unreal.FLinearColor>) : Void;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  static public function SelectString(A : unreal.FString, B : unreal.FString, bPickA : Bool) : unreal.FString;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  static public function SelectInt(A : unreal.Int32, B : unreal.Int32, bPickA : Bool) : unreal.Int32;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  static public function SelectFloat(A : unreal.Float32, B : unreal.Float32, bPickA : Bool) : unreal.Float32;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  static public function SelectVector(A : unreal.FVector, B : unreal.FVector, bPickA : Bool) : unreal.FVector;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  static public function SelectRotator(A : unreal.FRotator, B : unreal.FRotator, bPickA : Bool) : unreal.FRotator;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  static public function SelectColor(A : unreal.FLinearColor, B : unreal.FLinearColor, bPickA : Bool) : unreal.FLinearColor;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  static public function SelectTransform(A : unreal.Const<unreal.PRef<unreal.FTransform>>, B : unreal.Const<unreal.PRef<unreal.FTransform>>, bPickA : Bool) : unreal.FTransform;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  static public function SelectObject(A : unreal.UObject, B : unreal.UObject, bSelectA : Bool) : unreal.UObject;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  static public function SelectClass(A : unreal.UClass, B : unreal.UClass, bSelectA : Bool) : unreal.UClass;
  
  /**
    Build a reference frame from three axes
  **/
  static public function MakeRotationFromAxes(Forward : unreal.FVector, Right : unreal.FVector, Up : unreal.FVector) : unreal.FRotator;
  
  /**
    Create a rotator which orients X along the supplied direction vector
  **/
  static public function Conv_VectorToRotator(InVec : unreal.FVector) : unreal.FRotator;
  
  /**
    Get the X direction vector after this rotation
  **/
  static public function Conv_RotatorToVector(InRot : unreal.FRotator) : unreal.FVector;
  
  /**
    Returns true if A and B are equal (A == B)
  **/
  static public function EqualEqual_ObjectObject(A : unreal.UObject, B : unreal.UObject) : Bool;
  
  /**
    Returns true if A and B are not equal (A != B)
  **/
  static public function NotEqual_ObjectObject(A : unreal.UObject, B : unreal.UObject) : Bool;
  
  /**
    Returns true if A and B are equal (A == B)
  **/
  static public function EqualEqual_ClassClass(A : unreal.UClass, B : unreal.UClass) : Bool;
  
  /**
    Returns true if A and B are not equal (A != B)
  **/
  static public function NotEqual_ClassClass(A : unreal.UClass, B : unreal.UClass) : Bool;
  
  /**
    Determine if a class is a child of another class.
    
    @return      true if TestClass == ParentClass, or if TestClass is a child of ParentClass; false otherwise, or if either
                         the value for either parameter is 'None'.
  **/
  static public function ClassIsChildOf(TestClass : unreal.TSubclassOf<unreal.UObject>, ParentClass : unreal.TSubclassOf<unreal.UObject>) : Bool;
  
  /**
    Returns true if A and B are equal (A == B)
  **/
  static public function EqualEqual_NameName(A : unreal.FName, B : unreal.FName) : Bool;
  
  /**
    Returns true if A and B are not equal (A != B)
  **/
  static public function NotEqual_NameName(A : unreal.FName, B : unreal.FName) : Bool;
  
  /**
    Transform a position by the supplied transform.
    For example, if T was an object's transform, would transform a position from local space to world space.
  **/
  static public function TransformLocation(T : unreal.Const<unreal.PRef<unreal.FTransform>>, Location : unreal.FVector) : unreal.FVector;
  
  /**
    Transform a direction vector by the supplied transform - will not change its length.
    For example, if T was an object's transform, would transform a direction from local space to world space.
  **/
  static public function TransformDirection(T : unreal.Const<unreal.PRef<unreal.FTransform>>, Direction : unreal.FVector) : unreal.FVector;
  
  /**
    Transform a position by the inverse of the supplied transform.
    For example, if T was an object's transform, would transform a position from world space to local space.
  **/
  static public function InverseTransformLocation(T : unreal.Const<unreal.PRef<unreal.FTransform>>, Location : unreal.FVector) : unreal.FVector;
  
  /**
    Transform a direction vector by the inverse of the supplied transform - will not change its length.
    For example, if T was an object's transform, would transform a direction from world space to local space.
  **/
  static public function InverseTransformDirection(T : unreal.Const<unreal.PRef<unreal.FTransform>>, Direction : unreal.FVector) : unreal.FVector;
  
  /**
    Compose two transforms in order: A * B.
    
    Order matters when composing transforms:
    A * B will yield a transform that logically first applies A then B to any subsequent transformation.
    
    Example: LocalToWorld = ComposeTransforms(DeltaRotation, LocalToWorld) will change rotation in local space by DeltaRotation.
    Example: LocalToWorld = ComposeTransforms(LocalToWorld, DeltaRotation) will change rotation in world space by DeltaRotation.
    
    @return New transform: A * B
  **/
  static public function ComposeTransforms(A : unreal.Const<unreal.PRef<unreal.FTransform>>, B : unreal.Const<unreal.PRef<unreal.FTransform>>) : unreal.FTransform;
  
  /**
    Returns the given transform, converted to be relative to the given ParentTransform.
    
    Example: AToB = ConvertTransformToRelative(AToWorld, BToWorld) to compute A relative to B.
    
    @param               Transform               The transform you wish to convert
    @param               ParentTransform The transform the conversion is relative to (in the same space as Transform)
    @return              The new relative transform
  **/
  static public function ConvertTransformToRelative(Transform : unreal.Const<unreal.PRef<unreal.FTransform>>, ParentTransform : unreal.Const<unreal.PRef<unreal.FTransform>>) : unreal.FTransform;
  
  /**
    Returns the inverse of the given transform T.
    
    Example: Given a LocalToWorld transform, WorldToLocal will be returned.
    
    @param       T       The transform you wish to invert
    @return      The inverse of T.
  **/
  static public function InvertTransform(T : unreal.Const<unreal.PRef<unreal.FTransform>>) : unreal.FTransform;
  
  /**
    Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1).
  **/
  static public function TLerp(A : unreal.Const<unreal.PRef<unreal.FTransform>>, B : unreal.Const<unreal.PRef<unreal.FTransform>>, Alpha : unreal.Float32, InterpMode : unreal.ELerpInterpolationMode) : unreal.FTransform;
  
  /**
    Ease between A and B using a specified easing function.
  **/
  static public function TEase(A : unreal.Const<unreal.PRef<unreal.FTransform>>, B : unreal.Const<unreal.PRef<unreal.FTransform>>, Alpha : unreal.Float32, EasingFunc : unreal.EEasingFunc, BlendExp : unreal.Float32, Steps : unreal.Int32) : unreal.FTransform;
  
  /**
    Tries to reach a target transform.
  **/
  static public function TInterpTo(Current : unreal.Const<unreal.PRef<unreal.FTransform>>, Target : unreal.Const<unreal.PRef<unreal.FTransform>>, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.FTransform;
  
  /**
    Returns true if transform A is equal to transform B
  **/
  static public function EqualEqual_TransformTransform(A : unreal.Const<unreal.PRef<unreal.FTransform>>, B : unreal.Const<unreal.PRef<unreal.FTransform>>) : Bool;
  
  /**
    Returns true if transform A is nearly equal to B
    @param LocationTolerance        How close position of transforms need to be to be considered equal
    @param RotationTolerance        How close rotations of transforms need to be to be considered equal
    @param Scale3DTolerance         How close scale of transforms need to be to be considered equal
  **/
  static public function NearlyEqual_TransformTransform(A : unreal.Const<unreal.PRef<unreal.FTransform>>, B : unreal.Const<unreal.PRef<unreal.FTransform>>, LocationTolerance : unreal.Float32, RotationTolerance : unreal.Float32, Scale3DTolerance : unreal.Float32) : Bool;
  
  /**
    Returns addition of Vector A and Vector B (A + B)
  **/
  static public function Add_Vector2DVector2D(A : unreal.FVector2D, B : unreal.FVector2D) : unreal.FVector2D;
  
  /**
    Returns subtraction of Vector B from Vector A (A - B)
  **/
  static public function Subtract_Vector2DVector2D(A : unreal.FVector2D, B : unreal.FVector2D) : unreal.FVector2D;
  
  /**
    Returns Vector A scaled by B
  **/
  static public function Multiply_Vector2DFloat(A : unreal.FVector2D, B : unreal.Float32) : unreal.FVector2D;
  
  /**
    Element-wise Vector multiplication (Result = {A.x*B.x, A.y*B.y})
  **/
  static public function Multiply_Vector2DVector2D(A : unreal.FVector2D, B : unreal.FVector2D) : unreal.FVector2D;
  
  /**
    Returns Vector A divided by B
  **/
  static public function Divide_Vector2DFloat(A : unreal.FVector2D, B : unreal.Float32) : unreal.FVector2D;
  
  /**
    Returns Vector A added by B
  **/
  static public function Add_Vector2DFloat(A : unreal.FVector2D, B : unreal.Float32) : unreal.FVector2D;
  
  /**
    Returns Vector A subtracted by B
  **/
  static public function Subtract_Vector2DFloat(A : unreal.FVector2D, B : unreal.Float32) : unreal.FVector2D;
  
  /**
    Returns true if vector2D A is equal to vector2D B (A == B) within a specified error tolerance
  **/
  static public function EqualEqual_Vector2DVector2D(A : unreal.FVector2D, B : unreal.FVector2D, ErrorTolerance : unreal.Float32) : Bool;
  
  /**
    Returns true if vector2D A is not equal to vector2D B (A != B) within a specified error tolerance
  **/
  static public function NotEqual_Vector2DVector2D(A : unreal.FVector2D, B : unreal.FVector2D, ErrorTolerance : unreal.Float32) : Bool;
  
  /**
    Tries to reach Target based on distance from Current position, giving a nice smooth feeling when tracking a position.
    
    @param               Current                 Actual position
    @param               Target                  Target position
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated position
  **/
  static public function FInterpTo(Current : unreal.Float32, Target : unreal.Float32, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.Float32;
  
  /**
    Tries to reach Target at a constant rate.
    
    @param               Current                 Actual position
    @param               Target                  Target position
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated position
  **/
  static public function FInterpTo_Constant(Current : unreal.Float32, Target : unreal.Float32, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.Float32;
  
  /**
    Tries to reach Target based on distance from Current position, giving a nice smooth feeling when tracking a position.
    
    @param               Current                 Actual position
    @param               Target                  Target position
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated position
  **/
  static public function VInterpTo(Current : unreal.FVector, Target : unreal.FVector, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.FVector;
  
  /**
    Tries to reach Target at a constant rate.
    
    @param               Current                 Actual position
    @param               Target                  Target position
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated position
  **/
  static public function VInterpTo_Constant(Current : unreal.FVector, Target : unreal.FVector, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.FVector;
  
  /**
    Tries to reach Target based on distance from Current position, giving a nice smooth feeling when tracking a position.
    
    @param               Current                 Actual position
    @param               Target                  Target position
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated position
  **/
  static public function Vector2DInterpTo(Current : unreal.FVector2D, Target : unreal.FVector2D, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.FVector2D;
  
  /**
    Tries to reach Target at a constant rate.
    
    @param               Current                 Actual position
    @param               Target                  Target position
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated position
  **/
  static public function Vector2DInterpTo_Constant(Current : unreal.FVector2D, Target : unreal.FVector2D, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.FVector2D;
  
  /**
    Tries to reach Target rotation based on Current rotation, giving a nice smooth feeling when rotating to Target rotation.
    
    @param               Current                 Actual rotation
    @param               Target                  Target rotation
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated position
  **/
  static public function RInterpTo(Current : unreal.FRotator, Target : unreal.FRotator, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.FRotator;
  
  /**
    Tries to reach Target rotation at a constant rate.
    
    @param               Current                 Actual rotation
    @param               Target                  Target rotation
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated position
  **/
  static public function RInterpTo_Constant(Current : unreal.FRotator, Target : unreal.FRotator, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.FRotator;
  
  /**
    Interpolates towards a varying target color smoothly.
    
    @param               Current                 Current Color
    @param               Target                  Target Color
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated Color
  **/
  static public function CInterpTo(Current : unreal.FLinearColor, Target : unreal.FLinearColor, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.FLinearColor;
  
  /**
    Uses a simple spring model to interpolate a float from Current to Target.
    
    @param Current                               Current value
    @param Target                                Target value
    @param SpringState                   Data related to spring model (velocity, error, etc..) - Create a unique variable per spring
    @param Stiffness                             How stiff the spring model is (more stiffness means more oscillation around the target value)
    @param CriticalDampingFactor How much damping to apply to the spring (0 means no damping, 1 means critically damped which means no oscillation)
    @param Mass                                  Multiplier that acts like mass on a spring
  **/
  static public function FloatSpringInterp(Current : unreal.Float32, Target : unreal.Float32, SpringState : unreal.PRef<unreal.FFloatSpringState>, Stiffness : unreal.Float32, CriticalDampingFactor : unreal.Float32, DeltaTime : unreal.Float32, Mass : unreal.Float32) : unreal.Float32;
  
  /**
    Uses a simple spring model to interpolate a vector from Current to Target.
    
    @param Current                                Current value
    @param Target                                 Target value
    @param SpringState                    Data related to spring model (velocity, error, etc..) - Create a unique variable per spring
    @param Stiffness                              How stiff the spring model is (more stiffness means more oscillation around the target value)
    @param CriticalDampingFactor  How much damping to apply to the spring (0 means no damping, 1 means critically damped which means no oscillation)
    @param Mass                                   Multiplier that acts like mass on a spring
  **/
  static public function VectorSpringInterp(Current : unreal.FVector, Target : unreal.FVector, SpringState : unreal.PRef<unreal.FVectorSpringState>, Stiffness : unreal.Float32, CriticalDampingFactor : unreal.Float32, DeltaTime : unreal.Float32, Mass : unreal.Float32) : unreal.FVector;
  
  /**
    Resets the state of a given spring
  **/
  static public function ResetFloatSpringState(SpringState : unreal.PRef<unreal.FFloatSpringState>) : Void;
  
  /**
    Resets the state of a given spring
  **/
  static public function ResetVectorSpringState(SpringState : unreal.PRef<unreal.FVectorSpringState>) : Void;
  
  /**
    Returns a uniformly distributed random number between 0 and Max - 1
  **/
  static public function RandomIntegerFromStream(Max : unreal.Int32, Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : unreal.Int32;
  
  /**
    Return a random integer between Min and Max (>= Min and <= Max)
  **/
  static public function RandomIntegerInRangeFromStream(Min : unreal.Int32, Max : unreal.Int32, Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : unreal.Int32;
  
  /**
    Returns a random bool
  **/
  static public function RandomBoolFromStream(Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : Bool;
  
  /**
    Returns a random float between 0 and 1
  **/
  static public function RandomFloatFromStream(Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : unreal.Float32;
  
  /**
    Generate a random number between Min and Max
  **/
  static public function RandomFloatInRangeFromStream(Min : unreal.Float32, Max : unreal.Float32, Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : unreal.Float32;
  
  /**
    Returns a random vector with length of 1.0
  **/
  static public function RandomUnitVectorFromStream(Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : unreal.FVector;
  
  /**
    Create a random rotation
  **/
  static public function RandomRotatorFromStream(bRoll : Bool, Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : unreal.FRotator;
  
  /**
    Reset a random stream
  **/
  static public function ResetRandomStream(Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : Void;
  
  /**
    Create a new random seed for a random stream
  **/
  static public function SeedRandomStream(Stream : unreal.PRef<unreal.FRandomStream>) : Void;
  
  /**
    Set the seed of a random stream to a specific number
  **/
  static public function SetRandomStreamSeed(Stream : unreal.PRef<unreal.FRandomStream>, NewSeed : unreal.Int32) : Void;
  
  /**
    Finds the minimum area rectangle that encloses all of the points in InVerts
    Uses algorithm found in http://www.geometrictools.com/Documentation/MinimumAreaRectangle.pdf
    
    @param               InVerts - Points to enclose in the rectangle
    @outparam    OutRectCenter - Center of the enclosing rectangle
    @outparam    OutRectSideA - Vector oriented and sized to represent one edge of the enclosing rectangle, orthogonal to OutRectSideB
    @outparam    OutRectSideB - Vector oriented and sized to represent one edge of the enclosing rectangle, orthogonal to OutRectSideA
  **/
  static public function MinimumAreaRectangle(WorldContextObject : unreal.UObject, InVerts : unreal.Const<unreal.PRef<unreal.TArray<unreal.FVector>>>, SampleSurfaceNormal : unreal.Const<unreal.PRef<unreal.FVector>>, OutRectCenter : unreal.PRef<unreal.FVector>, OutRectRotation : unreal.PRef<unreal.FRotator>, OutSideLengthX : unreal.Float32, OutSideLengthY : unreal.Float32, bDebugDraw : Bool) : Void;
  
  /**
    Determines whether a given set of points are coplanar, with a tolerance. Any three points or less are always coplanar.
    
    @param Points - The set of points to determine coplanarity for.
    @param Tolerance - Larger numbers means more variance is allowed.
    
    @return Whether the points are relatively coplanar, based on the tolerance
  **/
  static public function PointsAreCoplanar(Points : unreal.Const<unreal.PRef<unreal.TArray<unreal.FVector>>>, Tolerance : unreal.Float32) : Bool;
  
  /**
    Computes the intersection point between a line and a plane.
    @param               T - The t of the intersection between the line and the plane
    @param               Intersection - The point of intersection between the line and the plane
    @return              True if the intersection test was successful.
  **/
  static public function LinePlaneIntersection(LineStart : unreal.Const<unreal.PRef<unreal.FVector>>, LineEnd : unreal.Const<unreal.PRef<unreal.FVector>>, APlane : unreal.Const<unreal.PRef<unreal.FPlane>>, T : unreal.Float32, Intersection : unreal.PRef<unreal.FVector>) : Bool;
  
  /**
    Computes the intersection point between a line and a plane.
    @param               T - The t of the intersection between the line and the plane
    @param               Intersection - The point of intersection between the line and the plane
    @return              True if the intersection test was successful.
  **/
  static public function LinePlaneIntersection_OriginNormal(LineStart : unreal.Const<unreal.PRef<unreal.FVector>>, LineEnd : unreal.Const<unreal.PRef<unreal.FVector>>, PlaneOrigin : unreal.FVector, PlaneNormal : unreal.FVector, T : unreal.Float32, Intersection : unreal.PRef<unreal.FVector>) : Bool;
  
}
